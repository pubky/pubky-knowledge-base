{"Architecture":{"title":"Architecture","links":["Explore/Technologies/KeyPair","Explore/Technologies/PubkyRing","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/Technologies/PKDNS","Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyCore/Introduction","Explore/Technologies/Homegate","Explore/Technologies/PubkyDocker","Explore/Technologies/PubkyCLI","Explore/Technologies/PubkyExplorer","Explore/Technologies/Paykit","Explore/Technologies/PubkyNoise","Explore/PubkyCore/Authentication","GettingStarted","Explore/PubkyCore/SDK","Explore/PubkyCore/API","Comparisons","FAQ"],"tags":[],"content":"Pubky Architecture Overview\nThis page provides a comprehensive overview of the Pubky ecosystem architecture, showing how all components work together to enable decentralized, censorship-resistant applications.\n\nSystem Architecture\nflowchart TB\n    subgraph Identity[Identity Layer]\n        Ring[Pubky Ring]\n        Keys[Key Pairs]\n    end\n    \n    subgraph Discovery[Discovery Layer]\n        PKARR[PKARR Records]\n        DHT[Mainline DHT]\n        PKDNS[PKDNS Servers]\n    end\n    \n    subgraph Storage[Storage Layer]\n        HS1[Homeserver 1]\n        HS2[Homeserver 2]\n        HSN[Homeserver N]\n    end\n    \n    subgraph Apps[Application Layer]\n        PubkyApp[Pubky App]\n        Nexus[Pubky Nexus]\n        Custom[Custom Apps]\n    end\n    \n    Ring --&gt; Keys\n    Keys --&gt; PKARR\n    PKARR --&gt; DHT\n    PKDNS --&gt; DHT\n    PKARR --&gt; HS1\n    HS1 --&gt; Nexus\n    HS2 --&gt; Nexus\n    Nexus --&gt; PubkyApp\n    Custom --&gt; HS1\n\n\nLayer Breakdown\nIdentity Layer\nThe foundation of Pubky is cryptographic identity based on key pairs.\nComponents:\n\nPubky Ring: Mobile app for secure key management\nKey Pairs: Ed25519 public/private key pairs\nRecovery Files: Encrypted backups for key recovery\n\nHow It Works:\n\nUser generates a key pair (public + private key)\nPublic key becomes permanent identity (z-base-32 encoded)\nPrivate key stays secure on device, used for signing\nRecovery file enables backup and cross-device usage\n\nKey Properties:\n\n‚úÖ Self-sovereign (no registration with authorities)\n‚úÖ Portable across devices\n‚úÖ Permanent (never changes)\n‚úÖ Cryptographically secure\n\n\nDiscovery Layer\nThe discovery layer enables finding homeservers and resolving identities without central servers.\nComponents:\n\nPKARR: Public Key Addressable Resource Records\nMainline DHT: Distributed Hash Table (10M+ nodes)\nPKDNS: DNS servers for resolving public key domains\n\nHow It Works:\nsequenceDiagram\n    participant User\n    participant Ring as Pubky Ring\n    participant DHT as Mainline DHT\n    participant PKDNS\n    participant HS as Homeserver\n    \n    User-&gt;&gt;Ring: Create Identity\n    Ring-&gt;&gt;DHT: Publish PKARR Record\n    Note over DHT: Record contains homeserver URL\n    User-&gt;&gt;PKDNS: Resolve public key\n    PKDNS-&gt;&gt;DHT: Fetch PKARR Record\n    DHT-&gt;&gt;PKDNS: Return signed record\n    PKDNS-&gt;&gt;User: Return homeserver URL\n    User-&gt;&gt;HS: Connect to homeserver\n\nKey Features:\n\nDecentralized discovery (no central directory)\nCensorship resistant (15+ years proven infrastructure)\nSelf-published (users control their records)\nUpdateable (switch homeservers anytime)\n\n\nStorage Layer\nHomeservers store user data in a key-value format over HTTP/HTTPS.\nArchitecture:\nflowchart LR\n    User1[User 1] --&gt; HS1[Homeserver A]\n    User2[User 2] --&gt; HS1\n    User3[User 3] --&gt; HS2[Homeserver B]\n    User4[User 4] --&gt; HS3[Homeserver C]\n    \n    HS1 --&gt; DB1[(PostgreSQL)]\n    HS2 --&gt; DB2[(LMDB)]\n    HS3 --&gt; DB3[(Files)]\n\nKey Properties:\n\nUser Choice: Pick any homeserver or run your own\nData Ownership: You control your data\nPortability: Switch homeservers without losing data\nPersistence Backends: Files, LMDB, PostgreSQL, or SQL\n\nAPI Operations:\n\nPUT /pub/app/path - Store data\nGET /pub/app/path - Retrieve data\nDELETE /pub/app/path - Delete data\nLIST /pub/app/ - List directory\n\n\nApplication Layer\nApplications consume data from homeservers, either directly or through aggregation services.\nArchitecture Patterns:\n1. Simple Client-Homeserver\nflowchart LR\n    Client[Client App] &lt;--&gt; HS[Homeserver]\n\nUse Case: Personal apps, simple tools, direct data access\n2. Global Aggregator\nflowchart LR\n    HS1[Homeserver 1] --&gt; Agg[Aggregator]\n    HS2[Homeserver 2] --&gt; Agg\n    HS3[Homeserver N] --&gt; Agg\n    Agg --&gt; Client[Client App]\n\nUse Case: Social feeds, search, discovery (e.g., Pubky Nexus)\n3. Custom Backend\nflowchart TB\n    HS[Homeservers] --&gt; Agg[Custom Aggregator]\n    Agg --&gt; ML[ML Inference]\n    Agg --&gt; Search[Search Engine]\n    ML --&gt; API[Custom API]\n    Search --&gt; API\n    API --&gt; Client[Client]\n\nUse Case: Advanced features, recommendations, specialized processing\n\nData Flow Example: Publishing a Post\nsequenceDiagram\n    participant User\n    participant Ring as Pubky Ring\n    participant App as Pubky App\n    participant HS as Homeserver\n    participant Nexus\n    \n    User-&gt;&gt;Ring: Authorize App\n    Ring-&gt;&gt;App: Grant session token\n    User-&gt;&gt;App: Create post\n    App-&gt;&gt;HS: PUT /pub/pubky.app/posts/123\n    HS-&gt;&gt;HS: Verify signature\n    HS-&gt;&gt;HS: Store post data\n    HS-&gt;&gt;App: 200 OK\n    Nexus-&gt;&gt;HS: Poll /events endpoint\n    Nexus-&gt;&gt;HS: Fetch new post\n    Nexus-&gt;&gt;Nexus: Index post\n    App-&gt;&gt;Nexus: GET /v0/stream/posts\n    Nexus-&gt;&gt;App: Feed with new post\n\n\nComponent Responsibilities\nPubky Core\nPubky Core provides:\n\nProtocol specification\nHomeserver implementation\nSDK for all platforms\nAuthentication system\nAPI standards\n\nRepository: github.com/pubky/pubky-core\nPubky Ring\nPubky Ring handles:\n\nKey generation and storage\nApp authorization\nSession management\nRecovery file creation\n\nPlatforms: iOS, Android (React Native)\nPubky Nexus\nPubky Nexus provides:\n\nReal-time aggregation\nSocial graph indexing\nSearch and discovery\nHigh-performance API\n\nPKDNS\nPKDNS enables:\n\nPublic key domain resolution\nDNS-over-HTTPS support\nTraditional ICANN domain support\nSelf-hosted or public instances\n\nRepository: github.com/pubky/pkdns\nHomegate\nHomegate provides:\n\nSMS verification\nLightning payment verification\nSpam prevention\nPrivacy-preserving signup\n\nRepository: github.com/pubky/homegate\n\nInfrastructure Tools\nDevelopment Tools\n\nPubky Docker: Full stack in one command\nPubky CLI: Command-line homeserver management\nPubky Explorer: Web-based data browser\n\nWork in Progress\n\nPaykit: Payment protocol\nPubky Noise: Encrypted communication\n\n\nSecurity Model\nAuthentication\nSee Authentication for the full authentication flow.\nData Integrity\nAll data operations are signed:\n\nClient creates data\nClient signs hash with private key\nHomeserver verifies signature\nData stored with signature\nAnyone can verify authenticity\n\nTrust Model\nWhat you trust:\n\n‚úÖ Mathematics (cryptography)\n‚úÖ Your own keys\n‚ö†Ô∏è Your homeserver for availability (not integrity)\n\nWhat you DON‚ÄôT trust:\n\n‚ùå Central authorities\n‚ùå DNS registrars\n‚ùå Server operators to verify data (math does it)\n\n\nScalability Characteristics\nHorizontal Scaling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponentScaling MethodHomeserversAdd more servers, users distribute naturallyPKDNSRun multiple instances, cache aggressivelyNexusShard by user/data type, read replicasMainline DHTAlready 10M+ nodes, proven at scale\nPerformance Metrics\nTypical Latencies:\n\nPKARR lookup (cached): &lt; 100ms\nPKARR lookup (DHT): 500-2000ms\nHomeserver GET: 50-200ms\nNexus API: 10-50ms (sub-millisecond for cached)\n\n\nComparison to Other Architectures\nvs Traditional Web (Client-Server)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectTraditionalPubkyIdentityUsername@servicePublic key (permanent)Data StorageCompany serversUser-chosen homeserversPortabilityLocked-inFull portabilityCensorshipEasyVery difficult\nvs Blockchain\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectBlockchainPubkyFeesTransaction feesNoneSpeedSlow (blocks)Instant (HTTP)StorageExpensiveCheap (standard hosting)ScalabilityLimitedWeb-scale\nvs Pure P2P\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectPure P2PPubkyAvailabilityMust be onlineHomeservers always onMobile-FriendlyDifficultNative supportPerformanceVariableConsistentDiscoveryComplexDHT + PKDNS\n\nDeployment Patterns\nPersonal Use\nUser Device ‚Üí Pubky Ring ‚Üí Personal Homeserver\n\nBest for: Personal data, backups, full control\nSmall Team\nTeam Members ‚Üí Shared Homeserver ‚Üí Team Apps\n\nBest for: Collaborative projects, startups\nSocial Application\nUsers ‚Üí Public Homeservers ‚Üí Nexus Aggregator ‚Üí Social App\n\nBest for: Social media, discovery platforms\nEnterprise\nUsers ‚Üí Enterprise Homeserver + Custom Aggregator + Private Nexus ‚Üí Internal Apps\n\nBest for: Organizations with custom requirements\n\nSee Also\n\nGetting Started: Get started with Pubky\nPubky Core Overview: Protocol details\nSDK Documentation: Build applications\nAPI Reference: HTTP API specification\nComparisons: How Pubky differs from alternatives\nFAQ: Frequently asked questions\n"},"Comparisons":{"title":"Comparisons","links":["/","GettingStarted","FAQ","TheVisionOfPubky","Explore/PubkyCore/Introduction"],"tags":[],"content":"How Pubky Compares to Other Protocols\nUnderstanding how Pubky differs from other decentralized and federated protocols.\n\nQuick Comparison Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeaturePubkyNostrBlueskyFarcasterIPFSIdentity ModelSelf-sovereign keys (Ed25519)Self-sovereign keys (Schnorr)DIDs + handlesEthereum addressesContent-addressedStorageHomeservers (HTTP)Relays (WebSocket)Personal Data ServersHubs (P2P)IPFS nodes (DHT)DiscoveryMainline DHT (10M+ nodes)Relay listsDID directory (centralized)On-chain registryIPFS DHTData Mutability‚úÖ Yes‚úÖ Yes‚úÖ Yes‚úÖ Yes‚ùå No (content-addressed)Censorship Resistanceüü¢ Highüü° Mediumüî¥ Lowüü° Mediumüü¢ HighBlockchain Requirement‚ùå No‚ùå No‚ùå No‚úÖ Yes (Optimism)‚ùå NoTransaction Fees‚ùå None‚ùå None‚ùå None‚úÖ Gas fees‚ùå NoneAlways-Online Requirementüü° Partial (homeservers)üü° Partial (relays)‚ùå No (PDSs)üü° Partial (hubs)‚úÖ Yes (for hosting)Mobile-Friendly‚úÖ Yes‚úÖ Yes‚úÖ Yes‚úÖ Yesüü° LimitedData Portability‚úÖ Full‚úÖ Fullüü° Partialüü° Partial‚úÖ FullMaturityüöß Beta‚úÖ Production‚úÖ Production‚úÖ Production‚úÖ Production\nLegend: ‚úÖ Yes | ‚ùå No | üü° Partial | üü¢ High | üî¥ Low | üöß Work in Progress\n\nDetailed Comparisons\nPubky vs Nostr\nWhat They Have in Common:\n\nSelf-sovereign cryptographic identity\nNo blockchain or transaction fees\nData portability through key ownership\nOpen protocol and implementations\n\nKey Differences:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectPubkyNostrStorage ModelHomeservers (HTTP/HTTPS)Relays (WebSocket)DiscoveryMainline DHT (15+ years proven)Relay lists (client-configured)Data StructureKey-value store (files)Event stream (signed messages)Homeserver DiscoveryAutomatic via PKARR ‚Üí DHTManual relay configurationAlways-OnlineNot required (homeservers)Relays must stay onlineSemantic TaggingBuilt-in (Semantic Social Graph)Application-levelAPI ProtocolRESTful HTTPWebSocket subscriptionsScalabilityProven DHT infrastructureRelay-dependent\nWhen to Choose Pubky:\n\nNeed censorship-resistant discovery (DHT-based)\nWant familiar HTTP/REST APIs\nBuilding apps requiring mutable file storage\nNeed semantic social graph features\n\nWhen to Choose Nostr:\n\nWant real-time event streaming\nPrefer WebSocket-based architecture\nEcosystem maturity matters (more clients/relays)\nSimpler relay model appeals to you\n\n\nPubky vs Bluesky (AT Protocol)\nWhat They Have in Common:\n\nUser data portability\nFederation-capable architecture\nPersonal data servers\nSocial media focus\n\nKey Differences:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectPubkyBlueskyIdentityPublic keys (truly self-sovereign)DIDs + DNS handles (hybrid)DiscoveryMainline DHT (decentralized)DID directory (centralized)Account PortabilityAutomatic (update PKARR)Requires DID transferHandle SystemOptional vanity namesDNS-based handles requiredInfrastructure ControlUser chooses homeserverBluesky PBC controls directoryCensorship ResistanceHigh (DHT-based)Low (centralized components)Data FormatFlexible key-valueLexicon-based schemasCurrent StateBetaProduction\nKey Concern with Bluesky:\n\nCentralization: DID directory (plc.directory) is controlled by Bluesky PBC\nSingle point of failure: If the directory is compromised, identity resolution breaks\nGovernance: Protocol changes controlled by one entity\n\nWhen to Choose Pubky:\n\nTrue self-sovereignty is critical\nNo dependence on centralized services\nPrefer proven DHT technology\nBuilding for censorship-resistant use cases\n\nWhen to Choose Bluesky:\n\nWant production-ready ecosystem now\nLarge existing user base matters\nFamiliar with ActivityPub/federation\nDNS-based handles are important\n\n\nPubky vs Farcaster\nWhat They Have in Common:\n\nDecentralized social protocol\nUser-controlled data\nMultiple client support\n\nKey Differences:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectPubkyFarcasterIdentityOff-chain (key pairs)On-chain (Ethereum addresses)RegistrationFree (generate keys)Paid (on-chain transaction)StorageHomeservers (HTTP)Hubs (P2P gossip)FeesNoneGas fees on OptimismBlockchainNoneOptimism L2 requiredScalabilityHTTP server scaleHub network scaleDiscoveryMainline DHTOn-chain registryComplexitySimpler (no chain)More complex (chain + hubs)\nTrade-offs:\nPubky Advantages:\n\nNo blockchain dependency\nNo transaction fees\nSimpler architecture\nFaster onboarding (instant key generation)\n\nFarcaster Advantages:\n\nOn-chain identity verification\nEthereum ecosystem integration\nStronger identity guarantees\nProduction maturity\n\nWhen to Choose Pubky:\n\nWant to avoid blockchain complexity\nNo transaction fees requirement\nPrefer HTTP-based architecture\nNeed fastest possible onboarding\n\nWhen to Choose Farcaster:\n\nEthereum integration is valuable\nOn-chain verification important\nAlready in crypto ecosystem\nProduction maturity required\n\n\nPubky vs IPFS\nWhat They Have in Common:\n\nDecentralized data storage\nContent distribution\nNo central authority\n\nKey Differences:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectPubkyIPFSPrimary FocusMutable identity + dataImmutable content distributionAddressingIdentity-first (public keys)Content-first (CIDs)MutabilityNative (update anytime)Requires IPNS or external pointersUse CaseApplications with identityContent delivery and archivalData ModelKey-value (per user)Merkle DAG (content)DiscoveryMainline DHT (identity)IPFS DHT (content)Always-OnlineNo (homeservers persist)Yes (to host your content)Update MechanismDirect (PUT/DELETE)Republish with new CID\nComplementary Technologies:\nPubky and IPFS can work together:\n\nStore large immutable content on IPFS\nReference IPFS CIDs in Pubky homeserver data\nUse Pubky for identity, IPFS for content delivery\n\nWhen to Choose Pubky:\n\nBuilding identity-centric applications\nNeed mutable user data\nWant simple HTTP APIs\nSocial/collaboration apps\n\nWhen to Choose IPFS:\n\nContent immutability is critical\nBuilding CDN or archival system\nDeduplication important\nLarge file distribution\n\n\nArchitecture Comparison\nData Flow Comparison\nPubky:\nUser Key ‚Üí PKARR (DHT) ‚Üí Homeserver ‚Üí HTTP API ‚Üí Apps\n\nNostr:\nUser Key ‚Üí Relay List ‚Üí Relays (WebSocket) ‚Üí Apps\n\nBluesky:\nDID ‚Üí Directory ‚Üí PDS ‚Üí Lexicon API ‚Üí Apps\n\nFarcaster:\nEthereum Address ‚Üí On-chain Registry ‚Üí Hubs (P2P) ‚Üí Apps\n\nTrust Model Comparison\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProtocolTrust RequirementPubkyTrust homeserver for availability (not integrity)NostrTrust relays for availability (not integrity)BlueskyTrust Bluesky PBC for DID directoryFarcasterTrust Optimism L2 and hub operatorsIPFSTrust no one (content-addressed)\n\nMigration Paths\nMoving to Pubky From‚Ä¶\nFrom Nostr:\n\nExport event history\nConvert to Pubky data format\nPublish to homeserver\nUpdate discovery to PKARR\n\nFrom Bluesky:\n\nExport PDS data\nGenerate Pubky keys\nMigrate posts/profile\nPublish PKARR record\n\nFrom Centralized Platforms:\n\nExport data (if available)\nCreate Pubky identity\nImport and republish content\nAnnounce migration\n\n\nEcosystem Maturity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProtocolLaunch YearStatusNotable AppsPubky2024BetaPubky AppNostr2020ProductionDamus, Amethyst, PrimalBluesky2023ProductionBluesky SocialFarcaster2021ProductionWarpcastIPFS2015ProductionBrave, Opera, many apps\n\nCommon Misconceptions\n‚ÄùPubky is just another Nostr‚Äù\nFalse: While both use keys for identity, Pubky uses HTTP homeservers and Mainline DHT for discovery, not relays and manual configuration.\n‚ÄùBluesky is decentralized like Pubky‚Äù\nPartial: Bluesky has decentralized data servers but centralized identity (DID directory controlled by Bluesky PBC).\n‚ÄùFarcaster is more secure because it uses blockchain‚Äù\nNuanced: Blockchain provides different guarantees, not inherently more security. Pubky‚Äôs cryptographic signatures provide strong integrity without fees.\n‚ÄùIPFS can do everything Pubky does‚Äù\nFalse: IPFS is content-addressed and immutable. Pubky is identity-addressed and mutable. Different use cases.\n\nBottom Line: Choose Based on Your Needs\nChoose Pubky if:\n\n‚úÖ Self-sovereignty without compromise is critical\n‚úÖ Censorship resistance is a top priority\n‚úÖ You want proven, scalable infrastructure (Mainline DHT)\n‚úÖ No blockchain dependency is important\n‚úÖ HTTP/REST APIs are preferred\n‚úÖ Building social/collaborative applications\n‚úÖ Fast-growing ecosystem\n\nChoose Nostr if:\n\n‚úÖ Real-time event streaming is core to your app\n‚úÖ Existing ecosystem maturity matters now\n‚úÖ WebSocket-based architecture fits your needs\n‚úÖ Want maximum client/relay options today\n\nChoose Bluesky if:\n\n‚úÖ Need production-ready ecosystem immediately\n‚úÖ Federation model familiar from Mastodon\n‚úÖ DNS-based handles are important\n‚úÖ Okay with some centralized components\n\nChoose Farcaster if:\n\n‚úÖ Ethereum ecosystem integration valuable\n‚úÖ On-chain verification important\n‚úÖ Transaction fees acceptable\n‚úÖ Already in crypto ecosystem\n\nChoose IPFS if:\n\n‚úÖ Content immutability is required\n‚úÖ Building CDN or archival system\n‚úÖ Content-addressed data model fits\n‚úÖ Deduplication is valuable\n\n\nSee Also\n\nMain Documentation: Complete Pubky knowledge base\nGetting Started: Get started with Pubky\nFAQ: Frequently asked questions\nVision: Why we‚Äôre building Pubky\nPubky Core: Technical overview\n"},"Contributing":{"title":"Contributing","links":["Explore/PubkyCore/Introduction","Explore/Technologies/PubkyRing","Explore/PubkyApp/Introduction","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/PubkyCLI","Explore/Technologies/PKDNS","Explore/Technologies/Homegate","Explore/Technologies/PubkyDocker","FAQ","Troubleshooting"],"tags":[],"content":"Contributing to Pubky\nThank you for your interest in contributing to Pubky! This guide will help you get started.\n\nWays to Contribute\n1. Documentation\nHelp improve this knowledge base:\n\nFix typos and errors\nAdd missing information\nImprove clarity and explanations\nAdd examples and tutorials\nTranslate to other languages\n\n2. Code Contributions\nContribute to Pubky projects:\n\nPubky Core: Protocol and homeserver\nPubky Ring: Mobile key manager\nPubky App: Social application (Franky)\nPubky Nexus: Indexing service\nPubky CLI: Command-line tool\nPKDNS, Homegate, Pubky Docker: Infrastructure tools\n\n3. Community Support\nHelp others in the community:\n\nAnswer questions on Telegram\nHelp troubleshoot issues\nShare your projects and experiences\nWrite blog posts and tutorials\n\n4. Testing &amp; Bug Reports\nImprove quality through:\n\nTesting beta features\nReporting bugs with detailed reproduction steps\nSuggesting improvements\nValidating fixes\n\n\nContributing to Documentation\nQuick Edits\nFor small fixes (typos, links, formatting):\n\nFork the repository: github.com/pubky/pubky-knowledge-base\nMake your changes: Edit markdown files directly\nSubmit a pull request: Include a clear description\n\nLarger Contributions\nFor new pages or significant changes:\n\nDiscuss first: Open an issue to discuss your plans\nFollow the structure: Match existing page organization\nUse proper linking: Use wiki-links [[Page Name]] for internal links\nAdd to index: Update index.md if adding new major pages\nTest locally: Build with Quartz to verify\n\nBuild locally:\ncd pubky-knowledge-base/quartz\nnpm install\nnpm run docs\n# Visit http://localhost:8080\nDocumentation Style Guide\nMarkdown Conventions:\n\nUse # Title for page titles (H1, only one per page)\nUse ## Section for major sections (H2)\nUse ### Subsection for subsections (H3)\nUse wiki-links for internal references: [[Page Name]]\nUse standard markdown links for external URLs: [text](url)\n\nCode Blocks:\n// Always specify language\nconst example = &quot;like this&quot;;\nLinking:\n&lt;!-- Internal (wiki-link) --&gt;\n[[Pubky Core]]\n[[Explore/PubkyCore/Introduction|Pubky Core Overview]]\n \n&lt;!-- External --&gt;\n[Official Docs](pubky.github.io/pubky-core/)\nImages:\n&lt;!-- Always include descriptive alt text --&gt;\n![Pubky Core architecture diagram showing homeservers, PKARR, and DHT](Explore/images/pubky-core.png)\n\nContributing Code\nGeneral Process\n\nCheck existing issues: See if someone is already working on it\nOpen an issue: Describe what you want to build/fix\nFork and branch: Create a feature branch\nWrite code: Follow project conventions\nTest thoroughly: Ensure tests pass\nSubmit PR: Include description and link to issue\n\nProject-Specific Guidelines\nEach repository has its own CONTRIBUTING.md:\n\nPubky Core: github.com/pubky/pubky-core/blob/main/CONTRIBUTING.md\nPubky Nexus: github.com/pubky/pubky-nexus/blob/main/CONTRIBUTING.md\nPubky Ring: github.com/pubky/pubky-ring/blob/main/CONTRIBUTING.md\nPubky CLI: github.com/pubky/pubky-cli/blob/main/CONTRIBUTING.md\n\nCode Quality Standards\nAll code contributions should:\n\n‚úÖ Pass existing tests\n‚úÖ Add tests for new features\n‚úÖ Follow language-specific style guides\n‚úÖ Include documentation/comments where needed\n‚úÖ Not introduce new linter warnings\n‚úÖ Be accompanied by a clear commit message\n\nCommit Message Format:\ntype: brief description (max 72 chars)\n\nLonger explanation if needed. Wrap at 72 characters.\n\nFixes #123\n\nTypes:\n\nfeat: New feature\nfix: Bug fix\ndocs: Documentation only\nstyle: Code style (formatting, no logic change)\nrefactor: Code restructuring\ntest: Adding or updating tests\nchore: Maintenance tasks\n\nExample:\nfeat: add HTTPS record support to PKDNS\n\nImplements HTTPS DNS record type handling in the PKDNS resolver,\nenabling service binding records for modern applications.\n\nFixes #456\n\n\nDevelopment Setup\nPubky Core (Rust)\n# Clone\ngit clone github.com/pubky/pubky-core\ncd pubky-core\n \n# Build\ncargo build\n \n# Run tests\ncargo test\n \n# Run homeserver locally\ncd pubky-homeserver\ncargo run\n \n# Format code\ncargo fmt\n \n# Lint\ncargo clippy\nRequirements:\n\nRust 1.75+\nOpenSSL development libraries\n\nPubky Ring (React Native)\n# Clone\ngit clone github.com/pubky/pubky-ring\ncd pubky-ring\n \n# Install dependencies\nnpm install\ncd ios &amp;&amp; pod install &amp;&amp; cd ..\n \n# Run on iOS\nnpm run ios\n \n# Run on Android\nnpm run android\n \n# Run tests\nnpm test\n \n# Lint\nnpm run lint\nRequirements:\n\nNode.js 18+\nReact Native environment (Xcode for iOS, Android Studio for Android)\n\nPubky Nexus (Rust)\n# Clone\ngit clone github.com/pubky/pubky-nexus\ncd pubky-nexus\n \n# Start dependencies (Neo4j, Redis, PostgreSQL)\ndocker compose up -d neo4j redis postgres\n \n# Build\ncargo build\n \n# Run migrations\ncargo run --bin migrator\n \n# Run server\ncargo run --bin server\n \n# Run tests\ncargo test\nRequirements:\n\nRust 1.75+\nDocker for databases\nPostgreSQL, Neo4j, Redis\n\nPubky CLI (Rust)\n# Clone\ngit clone github.com/pubky/pubky-cli\ncd pubky-cli\n \n# Build\ncargo build\n \n# Install locally\ncargo install --path .\n \n# Run tests\ncargo test\n \n# Generate completions\npubky-cli tools completions bash &gt; completions.bash\n\nCommunity Guidelines\nCode of Conduct\nWe expect all contributors to:\n\nBe respectful: Treat everyone with respect and kindness\nBe collaborative: Work together constructively\nBe inclusive: Welcome diverse perspectives\nBe professional: Keep discussions focused and productive\nGive credit: Acknowledge others‚Äô contributions\n\nCommunication Channels\n\nTelegram: t.me/pubkycore - General discussion and support\nGitHub Issues: Bug reports and feature requests\nGitHub Discussions: Long-form conversations and proposals\nPull Requests: Code review and technical discussion\n\nGetting Help\nBefore asking:\n\nCheck the FAQ\nSearch existing issues\nRead the Troubleshooting guide\nReview relevant documentation\n\nWhen asking:\n\nBe specific about your problem\nInclude relevant code/logs\nMention what you‚Äôve tried\nSpecify your environment\n\n\nReview Process\nDocumentation PRs\n\nReviewed by documentation maintainers\nUsually merged within 1-3 days\nFocus on clarity, accuracy, and consistency\n\nCode PRs\nReview criteria:\n\nCode quality and style\nTest coverage\nPerformance implications\nSecurity considerations\nBreaking changes\nDocumentation updates\n\nTimeline:\n\nInitial review: 1-7 days\nRevisions: As needed\nMerge: After approval from maintainer(s)\n\nTips for faster review:\n\nKeep PRs focused and small\nInclude tests\nUpdate documentation\nRespond to feedback promptly\nBe patient and respectful\n\n\nSpecialized Contributions\nWriting Examples\nShare practical examples:\n\nCreate a repository: Your example project\nAdd to awesome-pubky: Link to curated list\nWrite a tutorial: Blog post or documentation\nRecord a video: Screencast or presentation\n\nBuilding Clients\nBuilding a Pubky App-compatible client?\n\nUse pubky-app-specs: npm package\nFollow the spec: Ensure interoperability\nTest against Nexus: Use nexus.pubky.app\nShare your work: Let the community know!\n\nRunning Infrastructure\nContributing infrastructure:\n\nPublic Homeserver: Host for community use\nPKDNS Instance: Provide DNS resolution\nNexus Instance: Run custom indexer\nPKARR Relay: Improve network performance\n\nTranslations\nHelp translate documentation:\n\nChoose a language: Check what needs translation\nCreate language folder: e.g., /es/ for Spanish\nTranslate markdown files: Maintain structure\nSubmit PR: Include translation credits\n\n\nRecognition\nContributors\nAll contributors are recognized in:\n\nRepository README files\nRelease notes for significant contributions\nCommunity shout-outs\n\nMaintainers\nConsistent, high-quality contributors may be invited to become maintainers with:\n\nMerge permissions\nRelease authority\nArchitecture input\n\n\nLicense\nBy contributing to Pubky projects, you agree that your contributions will be licensed under the MIT License (or the project‚Äôs specific license).\nMIT License Basics:\n\n‚úÖ Commercial use allowed\n‚úÖ Modification allowed\n‚úÖ Distribution allowed\n‚úÖ Private use allowed\n‚ö†Ô∏è No warranty provided\n\n\nGetting Started Checklist\nReady to contribute? Here‚Äôs your checklist:\nFor Documentation:\n\n Fork pubky-knowledge-base repository\n Make your changes\n Test locally with Quartz\n Submit pull request\n\nFor Code:\n\n Check project‚Äôs CONTRIBUTING.md\n Set up development environment\n Create feature branch\n Write code and tests\n Pass all checks (lint, test, build)\n Submit pull request\n\nFor Community:\n\n Join Telegram channel\n Introduce yourself\n Answer questions where you can\n Share your projects\n\n\nQuestions?\n\nDocumentation: Open an issue on pubky-knowledge-base\nCode: Check project-specific issues\nGeneral: Ask on Telegram\n\n\nThank you for contributing to Pubky! Together we‚Äôre building a decentralized, censorship-resistant web. üöÄ"},"Explore/Concepts/Censorship":{"title":"Censorship","links":["Explore/PubkyCore/Homeserver"],"tags":[],"content":"Censorship is the suppression or control of speech, communication, or information by a governing body or authority, often resulting in a lack of free expression and limited user autonomy.\nImagine you‚Äôve been using a social platform to share your thoughts and connect with others. One day, you notice that your posts are disappearing or are no longer visible to your friends. Your reach is being reduced, and your voice is being silenced. This is an example of censorship at play‚Äîwhen someone else decides what you can and cannot say online, and what others can and cannot see.\nWhy Censorship is Inevitable\nCensorship is inevitable in today‚Äôs web because many popular services, like social platforms, require centralized hosting. These platforms need servers to store data, deliver content, and provide other services. As long as centralized servers are involved, someone‚Äîbe it the server owner, government authority, or a corporate entity‚Äîcan decide what content is allowed and what is not.\nThe reality is that many centralized platforms serve millions of users, which makes them natural targets for censorship. Server operators can be pressured to comply with local laws or corporate policies, meaning that user content can be restricted, removed, or filtered at any time.\nHowever, this doesn‚Äôt mean we should accept censorship without a solution. Instead, we need systems that assume censorship is likely and empower users to navigate around it.\nHow Pubky Addresses Censorship\nIn Pubky, the approach is not to eliminate censorship entirely‚Äîbecause some level of censorship will always exist where there are centralized components‚Äîbut rather to provide users with a way to circumvent it when it happens.\n\n\nFlexible Hosting: Pubky provides a flexible hosting model using trusted servers known as homeservers. While these servers may be subject to censorship, Pubky ensures that users have the ability to migrate away from a censoring server whenever needed. Users can move their data, identities, and connections seamlessly, meaning they retain control even in the face of censorship.\n\n\nDecentralized Identity: In Pubky, user identities are not dependent on any single server. By using self-issued public keys, users maintain their identity even if they change hosting providers. This prevents identity loss when moving away from a server that engages in censorship.\n\n\nData Portability and Redundancy: Pubky ensures that user data can be exported and re-imported across servers without any loss. Users can also use multiple servers for redundancy, minimizing the risk of any single point of failure or censorship cutting them off from their data.\n\n\nImportant Aspects of Censorship Resistance\n\nData Control: Users should always have access to and control over their data, even if one hosting provider chooses to censor it. Pubky‚Äôs approach empowers users by ensuring they are not dependent on any one server.\nMigration and Interoperability: The ability to migrate data, identities, and connections between different homeservers helps users remain resilient against censorship. Interoperable systems mean that even if one provider blocks content, another can provide access.\nLocal Copies and Self-Hosting: Users can keep local copies of their data, and Pubky encourages self-hosting, giving users more control over what happens to their information and ensuring their content is not subjected to centralized oversight.\n\nChallenges and Considerations\n\nLegal Compliance: Censorship is often tied to legal requirements that hosting providers must comply with. Even decentralized systems will face challenges related to legal jurisdictions, and Pubky is designed to navigate but not entirely eliminate these legal issues.\nContent Moderation: Some forms of moderation are necessary‚Äîwhether it‚Äôs to filter out spam or harmful content. Pubky facilitates¬†user-controlled moderation, where individuals or groups decide what they want to see, rather than a centralized authority imposing a one-size-fits-all policy.\nRedundancy Limitations: While Pubky‚Äôs redundancy and migration features provide resilience, they depend on the presence of multiple homeservers options. During the early phases, users may face limited availability of alternative servers.\n\nCensorship on the web is inevitable, but that doesn‚Äôt mean users have to be powerless. With Pubky, you have the ability to choose your hosting, migrate your data, and maintain your identity‚Äîall key tools for resisting censorship. Pubky‚Äôs design assumes censorship will happen and provides the mechanisms needed to overcome it. This empowers users with true control, ensuring that no single entity can unilaterally suppress their voice. The future of the web lies in resilient, user-first systems that put individuals back in control of their online presence."},"Explore/Concepts/CredibleExit":{"title":"Credible Exit","links":["Explore/Technologies/DNS"],"tags":[],"content":"Credible Exit is the ability to leave a platform or service without losing access to your data, identity, or connections, ensuring full user control and portability.\nThis substack post by Gordon Brander is a good introduction to the topic.\nImagine you‚Äôve built a social profile on a platform. Over time, you start noticing that some of your posts are being restricted or your content is no longer being promoted. You don‚Äôt want to lose everything you‚Äôve built‚Äîyour posts, connections, or even your online identity. This is where Credible Exit comes into play. It ensures that you can leave a platform without losing what‚Äôs yours, giving you true control over your online presence.\nIt is also important for the credible exit to be feasible, as in a measure of cost, meaning the cost of exit should be within the order of magnitude of making an exit economically efficient.\nWhy Credible Exit is Important\nToday, most platforms hold your data hostage. They make it difficult to leave, and if you do leave, you often lose all your posts, connections, and your ability to stay visible. This is the result of centralized control‚Äîa few big platforms deciding what can be shared and who gets to see it. They can censor you or limit your access without warning.\nHere are some of the best examples of Credible Exit in practice:\n\nDomain Name System (DNS): DNS is a classic example of a system that allows for a credible exit. If you no longer want your domain hosted with one provider, you can transfer it to another without losing control over your domain name.\nEmail Protocols (IMAP/SMTP): Email is another example. Users can change email providers while keeping the same email address, ensuring they don‚Äôt lose their communication history or contacts.\nBitcoin Wallets: Bitcoin wallets offer credible exit by allowing users to export private keys and import them into another wallet provider, retaining full control over their funds and transactions.\n\nCredible Exit is a fundamental principle that ensures users are never locked in. It means having the freedom to move your data, identity, and content to a new service without losing anything. It gives you leverage, making sure that platforms compete for your trust rather than taking it for granted.\nHow Pubky Makes Credible Exit Possible\nIn Pubky, Credible Exit is not just an idea‚Äîit‚Äôs built into the architecture. Pubky combines decentralized routing and identity with flexible, user-controlled hosting to make sure you‚Äôre always in charge.\n\n\nTrusted Servers with a Safety Net: When you join Pubky, you can use a trusted server to host your data. These servers are there to provide convenience, but you‚Äôre never stuck. If the server changes its policies or you simply want to move, Pubky allows you to seamlessly migrate your data to another server without any loss of content or followers.\n\n\nDecentralized Identity: With Pubky, your identity is not tied to any one server. You use self-issued public keys that are recognized across the network. This means you can change where your data is hosted without losing your identity or connections.\n\n\nData Portability: Pubky‚Äôs design ensures that all of your data can be easily exported and imported between servers. This keeps your content intact and visible, regardless of where it‚Äôs hosted.\n\n\n\nNOTE: During Pubky‚Äôs initial bootstrapping phase, credible exit may not be practically possible until more homeserver providers join. Synonym is building tools to make it easy for businesses and users to self-host.\n\nImportant Aspects of Credible Exit\n\nProtocols: The foundation of credible exit, enabling communication and data transfer between systems.\nData Importance: Differentiating between basic data (content created by users) and generated data (interactions, likes, comments), which may require different approaches for exit.\nDimensions of Credible Exit: Including the ability to export data, sync data across platforms, use data in useful formats, and store data in local files.\n\nChallenges and Considerations\n\nStatic Exports: While GDPR regulations allow for data exports, the static nature of these exports can limit their utility for ongoing use.\nData Formats: The importance of using common, useful formats for data to ensure it can be utilized elsewhere.\nInteroperability: The potential for multiple apps to share data through permissionless APIs, enhancing broad interoperability.\n\nSummary\nCredible Exit is about freedom and control. It ensures that you‚Äôre never at the mercy of a single platform or server. With Pubky, you get the convenience of using trusted servers while always having an exit strategy‚Äîone that guarantees you keep everything you‚Äôve built online. This is the foundation of a more open, user-first web, where platforms must earn your trust rather than exploit it."},"Explore/Concepts/SemanticSocialGraph":{"title":"Semantic Social Graph","links":[],"tags":[],"content":"\nSemantic Relationships: Connections between users and content are tagged with meaningful metadata, capturing the context, relevance, and nature of each relationship.\nWeighted Connections: Relationships aren‚Äôt just binary; they carry weights that represent their strength, trust level, or relevance, enabling more sophisticated interactions.\nUser-Centric Personalization: Users have control over how they interact with the network, allowing them to tailor their experience based on their interests and connections.\nDecentralization: There‚Äôs no central authority controlling the network. Users own their identities and data, promoting privacy and sovereignty.\nWhy It Matters\nEnhanced Content Curation: By understanding the semantic meaning and weights of relationships, users receive content that‚Äôs more relevant and engaging.\nScalability: Automated tagging and weighting mechanisms scale effortlessly, accommodating growing networks without compromising performance.\nRich Interactions: Users can engage in more meaningful ways, as the network understands the context and nuances of each relationship.\nSemantic Graphs in Pubky App\nThe Pubky App is a user-friendly platform that showcases the capabilities of Pubky Core and PKARR.\nSocial Tagging: Users can tag posts, files, links, and even peers with meaningful labels. This enriches the semantic content of the network.\nCustomizable Feeds: By utilizing tags and weighted relationships, users control what appears in their feeds, ensuring content relevance.\nPeer Tagging: Assign semantic tags to peers, influencing how their content is weighted and displayed.\nWeb of Relevance: Move beyond the traditional Web-of-Trust paradigm to a network where relevance and context drive interactions.\nHow Pubky Applies Decentralized Networking and Social Graphing\nPubky combines decentralized identity, semantic social tagging, and weighted relationships into a cohesive system that offers unparalleled user control and personalization.\nSemantic Social Graphing\nWeighted Distances: Relationships aren‚Äôt just connections; they have weights that represent their strength or relevance to the user.\nAdvanced Content Curation\nPersonalized Feeds: Users define what content matters to them, and the network delivers it based on semantic relevance and weighted relationships.\nDynamic Filtering: Adjust your view of the network in real-time by modifying tags and weights, ensuring your feed evolves with your interests.\nWhy It‚Äôs Different\nPubky bridges the gap between decentralized identity management and personalized content curation, something traditional models haven‚Äôt achieved.\nEnhancing Privacy and Security: By eliminating centralized points of control, Pubky reduces vulnerabilities and enhances user privacy.\nPromoting Open Innovation: As an open-source project, Pubky invites developers and enthusiasts to contribute, fostering a community-driven evolution of the platform."},"Explore/PubkyApp/AppArchitectures/1.Introduction":{"title":"Introduction","links":["Explore/PubkyCore/Introduction","Explore/PubkyCore/Homeserver","Explore/PubkyApp/AppArchitectures/2.ClientHomeserver","Explore/PubkyApp/AppArchitectures/4.CustomBackend","Explore/PubkyApp/AppArchitectures/3.GlobalAggregators"],"tags":[],"content":"Leveraging the Pubky Core protocol as the foundational layer, we can envision a diverse array of applications with distinct functionalities. While each app can implement its own unique design patterns and user interfaces, they all share a common underlying architecture: interacting with the distributed data stores, colloquially referred to as homeservers, through standardized read and write operations.\nThe Pubky Core protocol enables a decentralized approach to data management, facilitating seamless communication between clients and their respective data stores. This architecture promotes data sovereignty and enhances system resilience.\nBelow, we present several high-level designs that showcase the versatility of this architecture, from simple client (browser) apps that interact directly with one or several homeservers to more complex applications with custom aggregators and backends capable of powerful inference:\n\nClient-Homeserver\nCustom backend\nGlobal aggregators\n"},"Explore/PubkyApp/AppArchitectures/2.ClientHomeserver":{"title":"Client - Homeserver","links":[],"tags":[],"content":"\nIn this architecture, we implement a direct communication model between the client application and the home server. This approach minimizes latency and reduces system complexity by establishing a direct data flow pathway.\nThis design pattern is particularly well-suited for applications with straightforward functionality, especially those that don‚Äôt require real-time interaction or data normalization. This architectural approach demonstrates optimal performance in use cases characterized by intermittent data operations, where asynchronous read/write cycles are adequate for maintaining data consistency and fulfilling application requirements.\nTo illustrate the practical applications of this architectural paradigm, consider the following implementation scenarios:\n\nBookmark Management System: A client application designed to store and retrieve user bookmarks directly from the home server.\nFile Synchronization Utility: Similar to the open-source Syncthing project, this type of application would facilitate direct file synchronization between the client and the home server.\nText Snippet Repository: A lightweight application for creating, storing, and retrieving short text fragments or code snippets as pastebin\n\nThese implementations leverage the Pubky Core protocol to establish secure, efficient, and direct data exchange channels between the client and the home server, while the user remains with ownership of their data."},"Explore/PubkyApp/AppArchitectures/3.GlobalAggregators":{"title":"Global Aggregators","links":[],"tags":[],"content":"\nThis architectural pattern implements a distributed system model centered around a global aggregation layer, eliminating the need to fetch data from a multitude (maybe thousands!) of homesevers by the client. The core component of this design is a centralized global aggregator that interfaces with multiple home servers, consuming events from each in a unified manner.\nKey features of this architecture include:\n\nCentralized Event Processing: The global aggregator serves as a single point of convergence for event streams originating from disparate home servers across the network.\nPolicy-Driven Filtering: The aggregators can optionally implement a configurable set of policies and filtering rules, allowing for dynamic event processing based on predefined criteria.\nClient Flexibility and Aggregator Choice: Clients consume data from the global aggregator stream. However, if a client finds the enforced rules of one aggregator unsuitable, it retains the flexibility to switch to an alternative global aggregator that better aligns with its requirements or selectively look for the homeservers itself.\nScalable Event Distribution: By centralizing the aggregation process, this architecture facilitates efficient event distribution to multiple clients, potentially reducing redundant processing and network overhead.\n"},"Explore/PubkyApp/AppArchitectures/4.CustomBackend":{"title":"Custom Backend","links":["Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyApp/Introduction"],"tags":[],"content":"\nThis architectural design introduces a more sophisticated data flow model, incorporating an intermediary backend layer between the client application and the home server. This backend functions as a middleware, enhancing the system‚Äôs flexibility and data processing capabilities.\nThe backend can be potentially comprised with many components. These components will depend on the client app needs, but these are the main ones\n\nIndexer: Responsible for data normalization, ensuring consistent data structures and optimizing query performance.\nAggregator: Implements event filtering logic, allowing for selective data propagation based on predefined criteria.\n\nThis architecture supports two distinct data consumption patterns:\na) For scenarios requiring both data normalization and event filtering, the client interacts with the backend layer, as an endpoint. The aggregator processes the event stream from the home servers, applying filtering rules before passing the data to the indexer for normalization.\nb) In cases where only data normalization is necessary, the backend can bypass or not implement the aggregator, consuming events directly from the home server via the indexer.\nThis modular approach allows for fine-grained control over data processing, enabling efficient resource utilization and optimized client-side performance based on specific application requirements.\nPubky Nexus: Production Implementation\nPubky Nexus is the production-grade implementation of this custom backend architecture. It combines sophisticated aggregation, normalization, indexation, filtering (compliance), and powerful Social Semantic Graph inference capabilities.\nNexus powers the Pubky App social features with:\n\nReal-time event aggregation from multiple homeservers\nHigh-performance graph database (Neo4j) for relationship queries\nRedis caching layer for sub-millisecond response times\nComprehensive REST API with full OpenAPI specification\nAdvanced moderation and filtering capabilities\n\nResources:\n\nPubky Nexus Documentation - Complete feature overview\nGitHub Repository - Open source implementation\nLive API - Production Swagger UI\n"},"Explore/PubkyApp/AppArchitectures/index":{"title":"App Architectures","links":["Explore/PubkyApp/AppArchitectures/1.Introduction","Explore/PubkyApp/AppArchitectures/2.ClientHomeserver","Explore/PubkyApp/AppArchitectures/3.GlobalAggregators","Explore/PubkyApp/AppArchitectures/4.CustomBackend"],"tags":[],"content":"\nIntroduction\nClient - Homeserver\nGlobal Aggregators\nCustom Backend\n"},"Explore/PubkyApp/Backend/Aggregator":{"title":"Aggregator","links":["Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/PubkyNexus","Explore/Concepts/Censorship"],"tags":[],"content":"Pubky Aggregators\nAggregators are specialized reducers or gatekeepers that continuously scan and collect data from various sources, such as homeservers. They decide what data to allow in and what to keep out.\nWhen the aggregator receive new events, it evaluates it against its predefined criteria. If the data meets the criteria, the aggregator allows it to pass through, making it available for further processing or storage. However, if the data doesn‚Äôt meet the criteria, the aggregator blocks it, preventing it from entering the system.\nBy controlling the flow of information, aggregators play a crucial role in maintaining data quality, preventing information overload, and ensuring that only the most valuable and relevant data is used.\nPubky Nexus implements a production-grade aggregator (the nexus-watcher component) that monitors multiple homeservers in real-time, filtering events and updating the social graph continuously.\nCharacteristics\n\nFine-grained access controls: Users and aggregators have granular control over what data is shared, with whom, and under what conditions, ensuring selective and secure data exchange.\nEfficient data synchronization: Incremental sync via event streams enables fast and efficient synchronization of changes from homeservers, reducing the overhead of data aggregation.\nNormalized data schemas: Standardized data schemas facilitate interoperability between services, making it easier to integrate and exchange data across the network.\nPublic and niche aggregators: The network supports both large-scale, public aggregators for discoverability and smaller, niche aggregators that cater to specific communities or use cases.\nCore user graph expansion: The aggregation process starts with a core user graph and expands outward through connections, enabling the network to grow organically and efficiently.\nCensorship resistance: The system‚Äôs censorship resistance is achieved through a¬†decentralized aggregation architecture, where data aggregation is distributed across a network of¬†independent, autonomous aggregators. This design ensures that no single entity or node has control over the aggregation process, making it more resilient to censorship attempts.\n"},"Explore/PubkyApp/Backend/Indexer":{"title":"Indexer","links":["Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/PubkyNexus"],"tags":[],"content":"The Indexer is a specialized component that plays a crucial role in the system by normalizing and transforming the aggregated data from multiple homeservers into a unified view. This enables cross-data store search, queries, and discovery, allowing users to access and analyze data from various sources in a seamless and efficient manner.\nPubky Nexus is the production implementation of this indexer architecture, combining sophisticated event processing with Neo4j graph database and Redis caching for high-performance social graph operations.\nCharacteristics\n\nData Normalization: The Indexer normalizes the data from multiple sources, handling differences in format, structure, and schema. This involves transforming the data into a consistent format, resolving data conflicts, and ensuring that the data is accurate and reliable.\nData Transformation: The Indexer transforms the normalized data into a unified view, making it possible to query and analyze the data across multiple homeservers. This unified view enables users to access data from different sources as if it were a single, cohesive dataset.\nData Integrity: The Indexer ensures data integrity through secure synchronization protocols, guaranteeing that the indexed data is consistent and up-to-date. This involves implementing measures to prevent data corruption, ensuring that data updates are propagated across all data stores, and maintaining a high level of data quality and accuracy.\nScalability: The Indexer is designed to handle large volumes of data from multiple sources, ensuring that it can scale to meet the needs of a growing user base and increasing data demands.\n\nBy normalizing, transforming, and ensuring the integrity of the data, the Indexer provides a robust and scalable solution for cross-data store search, queries, and discovery"},"Explore/PubkyApp/Backend/Introduction":{"title":"Introduction","links":["Explore/PubkyApp/Backend/Aggregator","Explore/PubkyApp/Backend/Indexer","Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/WebServer","Explore/PubkyApp/Client/Introduction","Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyApp/Introduction"],"tags":[],"content":"The Backend is responsible for collecting (aggregators) and organizing (indexer) data from various sources, known as homeservers.\n\nImagine you‚Äôre trying to find a specific document in a large library. The backend is like a librarian who searches through the shelves, finds the right documents, and prepares them for you to use. This ensures that the data is accurate, up-to-date, and in a format that‚Äôs easy to work with.\nMain components\n\nAggregators execute a data retrieval protocol to obtain data from data storage, initiating a process that retrieves and collects data from various sources.\nIndexers receive aggregated data from the Aggregators and initiate a rigorous data normalization process, transforming and converting the data into a standardized format to ensure consistency and accuracy.\nWeb servers provide the requested data to Pubky client\n\nProduction Implementation\nPubky Nexus is the production-grade implementation of this backend architecture, powering Pubky App‚Äôs social features with real-time aggregation, high-performance indexing, and a comprehensive REST API."},"Explore/PubkyApp/Backend/PubkyNexus":{"title":"Pubky Nexus","links":["Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/Aggregator","Explore/PubkyApp/Backend/Indexer","Explore/PubkyApp/Backend/WebServer","Explore/PubkyApp/AppArchitectures/4.CustomBackend"],"tags":[],"content":"Pubky Nexus is the production-grade indexing and aggregation service that powers Pubky App‚Äôs social features. It transforms decentralized data from multiple homeservers into a high-performance social graph API, enabling real-time social media experiences at scale.\nOverview\nNexus serves as the central bridge between Pubky homeservers and social clients, implementing the aggregator, indexer, and web server components of the custom backend architecture. By aggregating events from homeservers into a rich social graph, Nexus provides the infrastructure needed for features like feeds, search, recommendations, and real-time notifications.\n\n‚ö†Ô∏è Note: The Nexus API is currently in active development. The service uses the /v0 route prefix to indicate API instability, and breaking changes may occur as the system evolves toward stability.\n\nKey Features\nReal-time Social Graph Aggregation\nNexus continuously ingests events from multiple Pubky homeservers, building and maintaining a structured social graph in real time. This enables features like:\n\nFollowing relationships and friend networks\nPost interactions (likes, replies, mentions)\nTag-based content discovery\nUser muting and moderation\n\nFull-Content Indexing\nRather than requiring clients to locate and query individual homeservers for content, Nexus indexes and serves content directly. This dramatically improves latency and user experience while still maintaining the decentralized nature of the underlying data. Clients can optionally verify content authenticity directly with homeservers when needed.\nHigh Performance &amp; Scalability\nBuilt in Rust with carefully optimized data structures, Nexus is designed for speed:\n\nSub-millisecond response times: Most requests are served in less than 1ms\nConstant time complexity: Query performance doesn‚Äôt degrade as user base grows\nEfficient caching: Redis-based caching layer accelerates common queries\nHorizontal scalability: Architecture supports distributed deployment\n\nSocial Semantic Graph (SSG)\nNexus supports Social Semantic Graph-based interactions, enabling:\n\nWeb-of-trust relationship mapping\nContent filtering based on social connections\nPersonalized feed ranking and recommendations\nCommunity detection and trust inference\n\nGraph-Enhanced Search &amp; Recommendations\nLeveraging Neo4j for graph database operations, Nexus provides:\n\nDeep relationship queries across the social graph\nRecommendation algorithms based on network topology\nTag and content discovery through graph traversal\nInfluencer and community identification\n\nFlexible Caching Architecture\nA sophisticated Redis caching layer ensures optimal performance:\n\nCommon queries cached for instant retrieval\nIncremental cache updates on new events\nMinimal database load for read-heavy workloads\nCache invalidation synchronized with graph updates\n\nArchitecture\nNexus is composed of several specialized components working together:\nComponents\n\n\nnexus-watcher: The event aggregator that monitors Pubky homeservers\n\nSubscribes to homeserver event streams\nFilters and validates incoming events\nTranslates events into social graph updates\nHandles retry logic for failed operations\n\n\n\nnexus-webapi: The REST API server (formerly nexus-service)\n\nServes client requests via HTTP/REST endpoints\nImplements OpenAPI/Swagger specification\nHandles authentication and rate limiting\nReturns formatted responses to Pubky App frontend\n\n\n\nnexus-common: Shared library for common functionality\n\nDatabase connectors (Redis, Neo4j)\nData models and schemas\nQuery builders and utilities\nConfiguration management\n\n\n\nnexusd: Service orchestration daemon\n\nManages component lifecycle\nPerforms database migrations\nHandles reindexing operations\nProvides CLI for administration\n\n\n\nData Flow\n\n\nEvent Ingestion: The watcher monitors multiple homeservers, receiving events as they occur (new posts, follows, likes, etc.)\n\n\nEvent Processing: Events are validated, filtered based on configured rules, and transformed into graph operations\n\n\nIndexing: Processed events update both the Redis cache (for fast queries) and Neo4j graph database (for complex relationships)\n\n\nAPI Responses: Client requests hit the web API, which serves data from the optimized indexes with sub-millisecond latency\n\n\nTechnology Stack\n\nLanguage: Rust (for performance and safety)\nGraph Database: Neo4j (for relationship queries and graph algorithms)\nCache Layer: Redis (for high-speed access to common queries)\nAPI Framework: Axum (Rust web framework)\nObservability: OpenTelemetry integration (optional)\n\nAPI Endpoints\nNexus provides a comprehensive REST API for social features:\nLive API Access\n\nStaging (latest): nexus.staging.pubky.app/swagger-ui/\nProduction (stable): nexus.pubky.app/swagger-ui/\n\nExplore the full API specification, test queries, and view response schemas directly through the Swagger UI.\nKey Endpoint Categories\n\nUser endpoints: Profile data, follower/following relationships, user search\nPost endpoints: Post creation/retrieval, replies, mentions, bookmarks\nFeed endpoints: Timeline generation, filtered streams, personalized feeds\nTag endpoints: Tag-based discovery, trending tags, tag streams\nSearch endpoints: Full-text search across users and content\nGraph endpoints: Relationship queries, web-of-trust calculations\nNotification endpoints: Real-time notification delivery\n\nObservability &amp; Monitoring\nNexus provides rich observability features for operators:\nDatabase Exploration\n\nRedis Insight: Inspect cached data structures in real-time at http://localhost:8001/redis-stack/browser (local dev)\nNeo4j Browser: Visualize and query the social graph at http://localhost:7474/browser/ (local dev)\n\nTelemetry Integration\nOptional OpenTelemetry integration for production monitoring:\n\nDistributed tracing across components\nPerformance metrics and latency tracking\nError rate monitoring and alerting\nIntegration with tools like Signoz, Jaeger, or Prometheus\n\nDevelopment &amp; Deployment\nPrerequisites\n\nRust toolchain (latest stable)\nDocker and Docker Compose (for databases)\nNeo4j (graph database)\nRedis (caching layer)\n\nQuick Start\n# Clone the repository\ngit clone github.com/pubky/pubky-nexus\ncd pubky-nexus\n \n# Set up databases via Docker\ncd docker\ncp .env-sample .env\ndocker compose up -d\n \n# Run the service (uses default config)\ncargo run -p nexusd\n \n# Or run components individually\ncargo run -p nexusd -- watcher  # Run event watcher\ncargo run -p nexusd -- api      # Run API server\nConfiguration\nNexus uses a TOML configuration file (default location: $HOME/.pubky-nexus/config.toml). Custom config paths can be specified:\ncargo run -p nexusd -- --config-dir=&quot;custom/config/folder&quot;\nTesting &amp; Benchmarking\n# Load mock data for testing\ncargo run -p nexusd -- db mock\n \n# Run unit tests\ncargo nextest run -p nexus-common --no-fail-fast\ncargo nextest run -p nexus-watcher --no-fail-fast\ncargo nextest run -p nexus-webapi --no-fail-fast\n \n# Run benchmarks\ncargo bench -p nexus-webapi\ncargo bench -p nexus-webapi --bench user  # Specific endpoint\nData Migration System\nNexus includes a sophisticated migration manager for handling breaking changes to data structures:\nMigration Phases\n\nDual Write: New writes go to both old and new data sources simultaneously\nBackfill: Historical data is migrated from old to new source\nCutover: Reads switch to the new data source\nCleanup: Old data sources are safely removed\n\nManaging Migrations\n# Create a new migration\ncargo run -p nexusd -- db migration new MigrationName\n \n# Run pending migrations\ncargo run -p nexusd -- db migration run\n \n# Clear database (use with caution)\ncargo run -p nexusd -- db clear\nUse Cases\nNexus enables a variety of social features for applications built on Pubky:\nSocial Feeds\n\nChronological and algorithmic timelines\nFiltered feeds by tags, authors, or topics\nPersonalized recommendations based on social graph\nReal-time updates without polling\n\nDiscovery &amp; Search\n\nFull-text search across posts and users\nTag-based content discovery\nTrending topics and hot tags\nUser recommendations based on network proximity\n\nModeration &amp; Filtering\n\nUser muting and blocking\nCommunity-based filtering\nSpam detection and prevention\nCustom content policies per instance\n\nAnalytics &amp; Insights\n\nUser reach and influence metrics\nContent engagement tracking\nNetwork growth analysis\nCommunity detection and clustering\n\nDeployment Options\nSelf-Hosted Instance\nOrganizations can run their own Nexus instance with custom:\n\nContent filtering and moderation policies\nEvent source selection (which homeservers to index)\nCaching strategies and database configuration\nAPI rate limits and access controls\n\nPublic Instances\nThe Pubky team operates public instances:\n\nProduction: nexus.pubky.app\nStaging: nexus.staging.pubky.app\n\nHybrid Approaches\nClients can use a combination of:\n\nPublic Nexus instances for general discovery\nPrivate instances for specialized communities\nDirect homeserver queries for verification\n\nFuture Enhancements\nThe Nexus roadmap includes several planned improvements:\n\nLight-weight mode: Return homeserver URIs instead of full content\nFederation protocols: Inter-Nexus communication for global discovery\nAdvanced ML models: Improved recommendation algorithms\nReal-time WebSocket API: Push-based updates for clients\nContent delivery optimization: Edge caching and CDN integration\nEnhanced privacy controls: Encrypted graph operations\n\nContributing\nNexus is open source and welcomes contributions:\n\nFork the repository\nCreate a feature branch\nWrite tests for new functionality\nSubmit a pull request with clear description\n\nAll contributions should include tests and benchmarks where applicable.\nResources\n\nRepository: github.com/pubky/pubky-nexus\nSwagger UI (Staging): nexus.staging.pubky.app/swagger-ui/\nSwagger UI (Production): nexus.pubky.app/swagger-ui/\nIssue Tracker: github.com/pubky/pubky-nexus/issues\n\nBuilding Clients for Nexus\nIf you‚Äôre building a social client application to consume the Nexus API:\n\nData Model Specification: Use pubky-app-specs as your authoritative reference for data structures and validation rules\nClient Reference: The current web client at pubky.app is operational but its codebase is deprecated (not recommended for learning)\nNext-Generation Client: Franky is under development as the production-quality reference implementation (expected summer 2025)\nAPI Exploration: Use the Swagger UI to explore available endpoints and test queries\n\nSee Also\n\nAggregators - Event collection and filtering\nIndexers - Data normalization and transformation\nWeb Servers - API serving layer\nCustom Backend Architecture - Overall architecture pattern\nHomeservers - Data source and storage layer\n"},"Explore/PubkyApp/Backend/WebServer":{"title":"Web Server","links":["Explore/PubkyApp/Client/Features/Tags","Explore/PubkyApp/Client/Features/Profiles","Explore/Technologies/Paykit"],"tags":[],"content":"The system comprises a suite of¬†backend services¬†that orchestrate the integration of¬†data feeds,¬†search functionality, and¬†user interface configurations. The system provides a unified platform for data ingestion, processing, and presentation, enabling seamless interactions between the frontend and backend components.\nServices\n\nFeeds - Curated views of aggregated data presented to users. Can include timelines, tags, profiles, etc.\nSearch - Services that index aggregated data and enable full text/attribute searches.\nIdentity - It provides single sign-on through self-sovereign credentials.\nPayments - Payment discovery and coordination service using Paykit protocol (work in progress). Planned capabilities include:\n\nPublic directory API for payment method discovery\nEncrypted storage for payment requests and subscriptions\nPush notification relay for incoming payment notifications\nReceipt storage and verification\nSubscription management coordination\n\n‚ö†Ô∏è Note: Paykit is not production-ready and subject to significant changes.\n\nArchitecture\nThe web server can be designed and implemented using various architectural patterns, depending on the specific requirements of the data request workflow. Two prominent architectural styles that can be employed are:\n\nMonolithic Architecture: A¬†single-tiered architecture¬†where the web server is constructed as a self-contained unit, encompassing all necessary components and functionality. This approach is characterized by a¬†tightly-coupled¬†design, where all components are integrated into a single executable or deployable unit.\nMicroservices Architecture: A¬†multi-tiered architecture¬†where the web server is decomposed into a collection of¬†loosely-coupled, independent services that communicate with each other using¬†APIs¬†and¬†messaging protocols. Each microservice is responsible for a specific¬†business capability¬†or¬†data domain, enabling greater flexibility, scalability, and resilience.\n\nThe choice of architecture depends on various factors, including¬†data request patterns,¬†traffic volume,¬†performance requirements,¬†development team expertise, and¬†maintenance considerations."},"Explore/PubkyApp/Client/Features/Bookmarks":{"title":"Bookmarks","links":[],"tags":[],"content":"Bookmarks\nBookmarks are a feature that allows you to privately save post for later reference. Here are some ways you can use bookmarks:\n\nSave for later reading: If you come across a post that you don‚Äôt have time to read or engage with immediately, you can bookmark it to read later when you have more time.\nReference material: Bookmarks can serve as a repository for tweets that contain useful information, such as articles, tutorials, or resources, that you might need to refer to later. In that case, you can organise the posts by topic.\nPrivate note-taking: Bookmarks can serve as a private note-taking system, allowing you to save tweets that you want to remember without having to publicly like or retweet them.\n\nTo bookmark a post, simply click or tap the ‚ÄúBookmark‚Äù icon (it looks like a ribbon) on the post. You can access your bookmarked posts by clicking the button on top of the page."},"Explore/PubkyApp/Client/Features/Layouts":{"title":"Layouts","links":[],"tags":[],"content":"Layouts\nPubky client offers multiple customizable UI layouts for users that prefer different column, grid, and list layouts for their feeds."},"Explore/PubkyApp/Client/Features/Notifications":{"title":"Notifications","links":["Explore/PubkyApp/Client/Features/Posts"],"tags":[],"content":"Notifications\nPubky client tracks various event or activities the user may be interested in, and provides relevant notifications for interactions and other relevant activity to the user. Notifications are a way to keep you informed about what‚Äôs happening in the app, even when you‚Äôre not actively browsing your timeline.\nHere are some common types of notifications you might receive:\n\nMentions: When someone mentions you in a post, you‚Äôll receive a notification. This means they‚Äôve included your public key (pk:pubky) in their post.\nReplies: If someone replies to one of your post, you‚Äôll get a notification.\nRe-posts: If someone re-posts one of your posts, you‚Äôll get a notification.\nFollows: When someone new follows you, you‚Äôll receive a notification.\nQuote Posts: If someone quotes one of your posts, you‚Äôll receive a notification.\n"},"Explore/PubkyApp/Client/Features/Perspectives":{"title":"Perspectives","links":[],"tags":[],"content":"Perspectives\nUsers can save any custom-filtered view or feed as a ‚Äúperspective‚Äù which is basically a custom template of settings of tags, weights, users, reach, and trends. Perspectives can also save custom UI layouts for the user."},"Explore/PubkyApp/Client/Features/Posts":{"title":"Posts","links":["Explore/PubkyApp/Client/Features/Tags"],"tags":[],"content":"Posts\nIn Pubky client, a post is a message that a user publishes on the platform. Posts are the core content and they can contain a variety of information, including:\n\nText: There is not text limitation of plain text, which can include words, phrases, sentences, or even just a single character.\nMedia: Post can include various types of media, such as images and videos.\nTags: It is a keyword or phrase preceded by the ‚Äù#‚Äù symbol, which help categorize and make post discoverable by topic.\nMentions: References to other Pubky users, denoted by the ‚Äúpk‚Äù keyword which notify them of the post.\nLinks: URLs to external websites, articles, or other online content.\nEmojis: Small images or icons used to convey emotions or add tone to the tweet.\n\nUsers also can re-post and reply to posts"},"Explore/PubkyApp/Client/Features/Profiles":{"title":"Profiles","links":[],"tags":[],"content":"Profiles\nIn Pubky client, a¬†profile¬†refers to a user‚Äôs personal page on the app, which displays their information, posts, and other content. A Pubky profile is a unique identity that represents a public-key.\nHere are some key components of a Pubky profile:\n\nUsername: A unique handle or identifier that represents the user, often preceded by the ‚Äúpk‚Äù keyword(e.g. pk:uudfeafc1c6dhxxnaiyuzss5ln9i1ikpb8syht46qpnx4ksi6ho).\nProfile picture: A small image that represents the user, often a photo or logo.\nBio: A short description of the user, often including information about their interests, profession, or personality.\nWebsite: A link to the user‚Äôs personal website, blog, or other online presence.\nPosts: The user‚Äôs posts, which are displayed in reverse chronological order (newest tweets first).\nFollowers: The number of users who follow the profile, indicating the size of their audience.\nFollowing: The number of users that the profile follows, indicating the accounts they‚Äôre interested in.\nLists: The number of lists the user has created or been added to, which are curated groups of accounts.\n"},"Explore/PubkyApp/Client/Features/Search":{"title":"Search","links":[],"tags":[],"content":"Search\nWhile Tags &amp; Filters are the primary sorting tools, the app also provides limited traditional search capabilities."},"Explore/PubkyApp/Client/Features/Tags":{"title":"Tags","links":["tags/Pubky","tags/privacy","tags/segwit"],"tags":["Pubky","privacy","segwit"],"content":"Tags\nThey are keywords or phrases that are added to a tweet to help users find and engage with the content. Users can publicly assign contextual tags, like hashtags, to any other user or post. Tags can be used to filter posts and users. Users can also choose custom weighting of tags when filtering.\nHow do tags work?\n\nHashtags: Tags are denoted by the ‚Äù#‚Äù symbol, followed by a word or phrase. For example,Pubky,privacy, orsegwit.\nClickability: When you click on a tag, Pubky client takes you to a page that displays all the posts that have used that same tag.\nDiscovery: Tags help users discover new content, accounts, and conversations related to a specific topic.\nCategorization: Tags help categorize posts, making it easier for users to find and engage with content that interests them.\n"},"Explore/PubkyApp/Client/Features/Trends":{"title":"Trends","links":[],"tags":[],"content":"Trends\nPubky client can provide statistical views of the data it has access to and then establish visualizations and leaderboard lists of trending posts, tags, and users."},"Explore/PubkyApp/Client/Introduction":{"title":"Introduction","links":["Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyApp/Backend/Introduction","Explore/Concepts/CredibleExit","Explore/PubkyCore/Introduction","Explore/Technologies/Paykit","Explore/Technologies/PubkyNoise"],"tags":[],"content":"Pubky Client\n\nThe Pubky client is the user-facing application for interacting with the Pubky social network. It is available as a progressive web app (PWA) and will eventually support desktop applications.\nCurrent Implementation\n\nLive Application: pubky.app - Production PWA currently operational\nBackend: Powered by Pubky Nexus indexing service using Synonym hosted infrastructure\nStatus: The current client repository is deprecated and being replaced (see Development Status below)\n\nDevelopment Status\n\n‚ö†Ô∏è Important: The original client codebase (github.com/pubky/pubky-app) is deprecated and marked as transitional. A new implementation called franky is under development and expected summer 2025.\n\nFor Developers:\n\nBuilding Compatible Clients: Use pubky-app-specs as the authoritative data model specification\nLearning Reference: Wait for the franky repository to mature; the current codebase is not recommended for learning purposes\nContributing: Direct contributions to a future-proof codebase should target franky once ready\n\nUsing the library analogy, the Pubky Client is like a personalized research assistant who takes the prepared documents from the librarian (backend) and creates a customized report just for you. This report is designed to be easy to read and understand, with all the relevant information presented in a clear and concise manner.\n\n\nUsers are able to take control of the data and exit the Synonym hosted services and run their own without hampering discoverability (credible exit).\n\n\nPubky client uses the open Pubky Core for nearly all features, allowing users to avoid censorship by choosing self-hosting or alternate hosts without losing followers or integrity.¬†\n\n\nPubky also includes support for paykit, an open payment protocol (work in progress) for coordinating payments among peers supporting various methods. This allows users to potentially create payment flows for familiar experiences.\n\n\n‚ö†Ô∏è Note: Paykit is currently work in progress and not production-ready. Integrations in Bitkit (iOS and Android) serve as testbeds for protocol development, not production features. The protocol specification, security model, and implementation are subject to significant changes.\nPlanned Paykit Features (WIP):\n\nPay to profiles: Send payments to Pubky identities without requesting addresses/invoices\nMethod discovery: Discover which payment methods someone accepts (onchain, Lightning)\nEncrypted negotiation: Private Pubky Noise channels for secure payment coordination\nSubscriptions: Cryptographically signed recurring payment agreements\nZero custody: Users always control their keys and funds\n\nFuture Pubky app versions may leverage Paykit once it reaches production readiness to enable peer-to-peer data markets, creator monetization, and value exchange throughout the ecosystem.\n\nCommunities facilitate moderation and discovery around shared interests.\n"},"Explore/PubkyApp/ELI5":{"title":"ELI5","links":[],"tags":[],"content":"ELI5: Pubky App\nImagine you‚Äôre at a massive party where everyone is sharing stories, showing pictures, and having interesting conversations. You get to decide who you talk to and what stories you listen to. You have full control over how you interact with people‚Äîchoosing who to trust and which conversations to join. This is what Pubky App is like for the internet‚Äîit gives you the power to choose who you connect with and what you share, just like you would at a party, without anyone else deciding for you.\nPubky App is like having your own personal party host that you can fully control. Instead of letting big companies decide who sees your posts or what shows up in your feed, Pubky App gives you the power. It lets you decide which content you see, who you interact with, and how you organize your online world.\n\n\nYour Rules, Your Control: Pubky App lets you control your connections with simple rules. If you only want to hear from your closest friends or people who share your hobbies, you can easily decide that. There are no hidden algorithms deciding what you should pay attention to‚Äîyou are the one in charge.\n\n\nTags and Trust: With Pubky, you can tag people, posts, and content based on how much you trust them or how relevant they are to you. This means you can filter out the noise and focus on the people and content that really matter.\n\n\nMove Anytime: Imagine if you wanted to leave the party and join a different one, but still keep all your friends and stories with you. Pubky App lets you do that too. You can switch to a new service or hosting provider whenever you want, without losing your posts, friends, or identity. You‚Äôre never locked in.\n\n\nSo, with Pubky App, you‚Äôre in charge of your online world‚Äîdeciding who you talk to, what you see, and how you share. It‚Äôs about making the internet feel more like a real conversation with the people you care about, instead of letting algorithms decide for you."},"Explore/PubkyApp/Introduction":{"title":"Introduction","links":["Explore/PubkyCore/Homeserver","Explore/PubkyApp/Introduction","Explore/PubkyCore/Introduction","Explore/PubkyApp/Backend/Aggregator","Explore/PubkyApp/Client/Features/Search","Explore/PubkyApp/Backend/Introduction","Explore/PubkyApp/Client/Introduction","Explore/PubkyCore/Pkarr/0.Introduction","Explore/PubkyApp/Backend/PubkyNexus"],"tags":[],"content":"\n\nSynonym will be initially hosting: homeserver and Pubky App\n\nOverview\nPubky App is a decentralized social media application built on Pubky Core. It serves as a working reference implementation demonstrating how to build social applications on the Pubky protocol.\nThe data models and validation rules are formally specified in the pubky-app-specs repository, which defines structures for users, posts, tags, bookmarks, follows, and feeds. This specification ensures interoperability between different Pubky App implementations.\nLive Application &amp; Development Status\n\nLive Demo: pubky.app - Production instance currently operational\nCurrent Repository: github.com/pubky/pubky-app - ‚ö†Ô∏è Deprecated (MVP codebase, not for learning/contribution)\nNew Development: github.com/pubky/franky - Work in Progress (next-generation client, expected summer 2025)\nBuild Compatible Clients: Use pubky-app-specs as the authoritative specification\n\n\nNote for Developers: The original pubky-app repository presented at BTC Prague is deprecated and marked as ‚Äúvery hacky‚Äù by the team. If you want to build a compatible social client or learn from production-quality code, start with the pubky-app-specs specification and wait for the franky repository to mature. The current codebase at pubky-app is transitional and should not be used as a reference.\n\nKey aspects\n\nData Ownership: Users¬†have full autonomy over their data, hosting it on¬†independent homeservers¬†that are decentralized and distributed across the network. This approach enables users to maintain¬†control¬†and¬†ownership¬†of their data, while also ensuring¬†data sovereignty¬†and¬†privacy.\nProfiles: The system employs a¬†decentralized data storage¬†approach, where¬†post,¬†comment, and¬†like¬†data are stored in association with¬†user profiles.\nAggregators collecting social graphs\nFeeds of followings‚Äô activities\nSearching profiles and posts\nNotification delivery through application backends\nDistributed moderation through user blocking\n\nComponents\nThe Pubky App is a complex system that can be broken down into two main components: the backend and the client. These two pieces work together to provide a seamless user experience.\nBackend: The Data Organizer\nIt collects and organizes data from various sources, processing it into a usable format.\nClient: The User Interface\nIt is the part of the Pubky App that you interact with directly. It‚Äôs responsible for taking the organized data from the Backend and presenting it to you in a visually appealing and easy-to-understand way.\nMVP Architecture\nThe early versions of Pubky app take some shortcuts over the Pubky Core design. The MVP app is centralized, therefore we saved time and complexity by aggregating functionality into fewer components. The main two components are the Homeserver and the Indexer\n\nThe homeservers fulfils the function of data stores, republishing users keys to PKARR and it acts also as an identity-provider (Oauth-like sign-in). Users maintain a trust relationship with the homeserver.\nThe Indexer fulfils the function of the backend for the Pubky App. Pubky Nexus is the production implementation of this indexer, providing real-time social graph aggregation, high-performance search, and a comprehensive REST API.\n"},"Explore/PubkyApp/index":{"title":"Pubky App","links":["Explore/PubkyApp/Introduction","Explore/PubkyApp/AppArchitectures/1.Introduction","Explore/PubkyApp/Backend/Introduction","Explore/PubkyApp/Client/Introduction"],"tags":[],"content":"\nIntroduction\nApp Architectures\nBackend\nClient\n"},"Explore/PubkyCore/API":{"title":"API","links":["Introduction","Explore/PubkyCore/Homeserver","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/PubkyCore/Authentication","Explore/PubkyCore/SDK"],"tags":[],"content":"Pubky Core API Reference\nThe Pubky Core protocol defines a RESTful HTTP API for storing and retrieving data on homeservers. This document describes the complete API specification.\nBase URL\nAll API endpoints are relative to the homeserver base URL:\nhomeserver.example.com\n\nHomeserver URLs are discovered via PKARR records published to the Mainline DHT.\nAuthentication\nSee Authentication for conceptual overview.\nPublic Key Authentication\nAll requests must be authenticated using Ed25519 signatures:\nHeaders:\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\n\nSignature Generation:\n\nCreate message: METHOD:PATH:TIMESTAMP:BODY_HASH\nSign message with Ed25519 private key\nEncode signature as base64\n\nExample (conceptual):\nMethod: PUT\nPath: /pub/myapp/data\nTimestamp: 1704067200\nBody: {&quot;hello&quot;:&quot;world&quot;}\nBody Hash: sha256(body) = abc123...\n\nMessage to sign: &quot;PUT:/pub/myapp/data:1704067200:abc123...&quot;\nSignature: sign_ed25519(message, private_key)\n\nAuthorization: Pubky 8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo:SGVsbG8gV29ybGQ=:1704067200\n\nSession Tokens\nFor long-lived connections, use session tokens:\nRequest:\nPOST /auth/session\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\nContent-Type: application/json\n \n{\n  &quot;capabilities&quot;: [\n    &quot;read:/pub/&quot;,\n    &quot;write:/pub/myapp/&quot;\n  ],\n  &quot;ttl&quot;: 3600\n}\nResponse:\n{\n  &quot;token&quot;: &quot;session_abc123...&quot;,\n  &quot;expires_at&quot;: 1704070800\n}\nUsage:\nGET /pub/myapp/data\nAuthorization: Bearer session_abc123...\nStorage Endpoints\nPUT - Store Data\nStore or update data at a path.\nRequest:\nPUT /:path\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\nContent-Type: application/octet-stream\n \n&lt;binary data&gt;\nPath Format:\n\nMust start with /pub/ (public) or /private/ (future)\nMaximum length: 1024 bytes\nAllowed characters: a-z, A-Z, 0-9, -, _, /, .\n\nResponse:\nHTTP/1.1 200 OK\nContent-Type: application/json\n \n{\n  &quot;path&quot;: &quot;/pub/myapp/data&quot;,\n  &quot;size&quot;: 1234,\n  &quot;created_at&quot;: 1704067200\n}\nError Responses:\n\n400 Bad Request: Invalid path or data\n401 Unauthorized: Invalid authentication\n403 Forbidden: Insufficient permissions\n413 Payload Too Large: Data exceeds limit (default: 10MB)\n507 Insufficient Storage: Quota exceeded\n\nGET - Retrieve Data\nRetrieve data from a path.\nRequest:\nGET /:path\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\nResponse:\nHTTP/1.1 200 OK\nContent-Type: application/octet-stream\nContent-Length: 1234\n \n&lt;binary data&gt;\nError Responses:\n\n401 Unauthorized: Invalid authentication\n403 Forbidden: Insufficient permissions\n404 Not Found: Path does not exist\n\nDELETE - Remove Data\nDelete data at a path.\nRequest:\nDELETE /:path\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\nResponse:\nHTTP/1.1 200 OK\nContent-Type: application/json\n \n{\n  &quot;path&quot;: &quot;/pub/myapp/data&quot;,\n  &quot;deleted_at&quot;: 1704067200\n}\nError Responses:\n\n401 Unauthorized: Invalid authentication\n403 Forbidden: Insufficient permissions\n404 Not Found: Path does not exist\n\nLIST - Enumerate Data\nList entries under a path prefix (with pagination).\nRequest:\nGET /:path?limit=20&amp;cursor=abc123&amp;reverse=false\nAuthorization: Pubky &lt;public_key&gt;:&lt;signature&gt;:&lt;timestamp&gt;\nQuery Parameters:\n\nlimit (optional): Maximum entries to return (default: 100, max: 1000)\ncursor (optional): Pagination cursor from previous response\nreverse (optional): List in reverse order (newest first)\n\nResponse:\nHTTP/1.1 200 OK\nContent-Type: application/json\n \n{\n  &quot;entries&quot;: [\n    {\n      &quot;path&quot;: &quot;/pub/myapp/posts/001&quot;,\n      &quot;size&quot;: 512,\n      &quot;created_at&quot;: 1704067200,\n      &quot;updated_at&quot;: 1704067200\n    },\n    {\n      &quot;path&quot;: &quot;/pub/myapp/posts/002&quot;,\n      &quot;size&quot;: 1024,\n      &quot;created_at&quot;: 1704067300,\n      &quot;updated_at&quot;: 1704067300\n    }\n  ],\n  &quot;cursor&quot;: &quot;next_page_cursor_xyz&quot;,\n  &quot;has_more&quot;: true\n}\nError Responses:\n\n401 Unauthorized: Invalid authentication\n403 Forbidden: Insufficient permissions\n\nCapabilities System\nCapabilities define what operations a session can perform:\nCapability Syntax\n&lt;operation&gt;:&lt;path_prefix&gt;\n\nOperations:\n\nread: GET, LIST operations\nwrite: PUT, DELETE operations\n*: All operations\n\nExamples:\nread:/pub/                    # Read all public data\nwrite:/pub/myapp/             # Write to /pub/myapp/* only\n*:/pub/myapp/posts/           # Full access to posts\nread:/pub/social/profile      # Read specific path\n\nCapability Checking\nWhen a request is made:\n\nCheck session capabilities\nMatch requested path against capability patterns\nVerify operation is allowed\nExecute or deny request\n\nEvent Streaming (Future)\nSubscribe to real-time updates on data changes.\nRequest:\nGET /events?paths=/pub/myapp/&amp;since=1704067200\nAuthorization: Bearer session_abc123...\nResponse (Server-Sent Events):\nHTTP/1.1 200 OK\nContent-Type: text/event-stream\n \nevent: created\ndata: {&quot;path&quot;:&quot;/pub/myapp/posts/003&quot;,&quot;size&quot;:256,&quot;timestamp&quot;:1704067400}\n \nevent: updated\ndata: {&quot;path&quot;:&quot;/pub/myapp/profile&quot;,&quot;size&quot;:512,&quot;timestamp&quot;:1704067500}\n \nevent: deleted\ndata: {&quot;path&quot;:&quot;/pub/myapp/temp&quot;,&quot;timestamp&quot;:1704067600}\nAdmin Endpoints\nHomeserver administrators can access management endpoints:\nGET /admin/stats\nGet server statistics.\nResponse:\n{\n  &quot;users&quot;: 1000,\n  &quot;total_storage&quot;: 1073741824,\n  &quot;requests_per_minute&quot;: 150,\n  &quot;uptime_seconds&quot;: 86400\n}\nGET /admin/users/:public_key\nGet user information.\nResponse:\n{\n  &quot;public_key&quot;: &quot;8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo&quot;,\n  &quot;storage_used&quot;: 10485760,\n  &quot;storage_quota&quot;: 104857600,\n  &quot;created_at&quot;: 1704000000,\n  &quot;last_activity&quot;: 1704067200\n}\nSee Admin API for complete admin documentation.\nMetrics Endpoint\nPrometheus-compatible metrics for monitoring.\nGET /metrics\nResponse:\n# HELP pubky_requests_total Total HTTP requests\n# TYPE pubky_requests_total counter\npubky_requests_total{method=&quot;GET&quot;,status=&quot;200&quot;} 1000\npubky_requests_total{method=&quot;PUT&quot;,status=&quot;200&quot;} 500\n\n# HELP pubky_storage_bytes Total storage used\n# TYPE pubky_storage_bytes gauge\npubky_storage_bytes 1073741824\n\n# HELP pubky_active_sessions Current active sessions\n# TYPE pubky_active_sessions gauge\npubky_active_sessions 50\n\nRate Limiting\nHomeservers implement rate limiting to prevent abuse:\nHeaders:\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 95\nX-RateLimit-Reset: 1704067260\nRate Limit Exceeded:\nHTTP/1.1 429 Too Many Requests\nRetry-After: 60\n \n{\n  &quot;error&quot;: &quot;rate_limit_exceeded&quot;,\n  &quot;message&quot;: &quot;Too many requests, try again in 60 seconds&quot;\n}\nDefault Limits:\n\nAnonymous: 10 requests/minute\nAuthenticated: 100 requests/minute\nAdmin: Unlimited\n\nError Responses\nAll errors follow a consistent format:\n{\n  &quot;error&quot;: &quot;error_code&quot;,\n  &quot;message&quot;: &quot;Human-readable error message&quot;,\n  &quot;details&quot;: {\n    &quot;additional&quot;: &quot;context&quot;\n  }\n}\nCommon Error Codes:\n\ninvalid_path: Path format is invalid\ninvalid_signature: Authentication signature invalid\nexpired_session: Session token expired\ninsufficient_permissions: Operation not allowed\nstorage_quota_exceeded: User quota exceeded\nrate_limit_exceeded: Too many requests\nserver_error: Internal server error\n\nBest Practices\nEfficient List Operations\nPaginate large datasets:\nasync function getAllPosts(client, publicKey) {\n    const allPosts = [];\n    let cursor = null;\n    \n    do {\n        const response = await client.list(\n            `pubky://${publicKey}/pub/myapp/posts/`,\n            { limit: 100, cursor }\n        );\n        \n        allPosts.push(...response.entries);\n        cursor = response.cursor;\n    } while (response.has_more);\n    \n    return allPosts;\n}\nOptimize Storage\nStore structured data efficiently:\n// Good: Separate entries for each post\nPUT /pub/myapp/posts/001  (small JSON)\nPUT /pub/myapp/posts/002  (small JSON)\nPUT /pub/myapp/posts/003  (small JSON)\n \n// Bad: Single large entry\nPUT /pub/myapp/all_posts  (large JSON array)\nHandle Errors Gracefully\nasync function robustPut(client, path, data) {\n    const maxRetries = 3;\n    \n    for (let i = 0; i &lt; maxRetries; i++) {\n        try {\n            return await client.put(path, data);\n        } catch (error) {\n            if (error.code === &#039;rate_limit_exceeded&#039;) {\n                await sleep(error.retryAfter * 1000);\n                continue;\n            }\n            throw error;\n        }\n    }\n}\nResources\n\nPubky Core Overview: Main documentation\nSDK Documentation: Client libraries\nHomeserver Documentation: Server setup\nOfficial Docs: pubky.github.io/pubky-core\nRepository: github.com/pubky/pubky-core\n\n\nThe Pubky Core API provides a simple, RESTful interface for decentralized data storage."},"Explore/PubkyCore/Authentication":{"title":"Authentication","links":["Explore/PubkyCore/Homeserver"],"tags":[],"content":"Pubky uses decentralized authentication where users control their own cryptographic keys. There are no central identity providers.\nKey Concepts\n\nAuthenticator: Any software or hardware capable of Ed25519 signing, such as Pubky Ring.\nCapabilities: Permissions defining what an app can access (e.g., /pub/pubky.app/:rw has read and write permissions for path ‚Äú/pub/pubky.app`).\nAuthToken: A signed, time-limited token granting access to the Homeserver. Created by the Authenticator, processed by the SDK, and verified by the Homeserver.\n\nUser Flow with Pubky Ring\nApps display a QR code, the user scans it with Pubky Ring, reviews permissions, and approves. The full flow is documented in AUTH.md.\nCurrent Limitations\n\nSingle session per app: Logging into App B overwrites App A‚Äôs session. This is unintended behavior, see issue #122.\nNo key delegation: AuthToken must be signed by the user‚Äôs main key.\n"},"Explore/PubkyCore/ELI5":{"title":"ELI5","links":[],"tags":[],"content":"Explaining Pubky Core Like You‚Äôre 5 Years Old\nImagine you have a special toy castle that you built, and you want your friends to come and play with it. Maybe you set up your castle in your backyard, or in the park, or at your grandma‚Äôs house. You tell your friends where it is so they can come play.\nNow, suppose you chose the park, but it is closed, or someone says you can‚Äôt keep your castle there anymore. No worries!\nYou Move the Castle: You pick up your castle and set it up somewhere else, like your backyard.\nYou Tell Your Friends: You let your friends know the new spot so they can still come and play.\nSo, what is Pubky Core?\nPubky Core is like you being in charge of where your stuff lives on the internet. Even if things change‚Äîlike someone tries to block your stuff or you decide to move it‚Äîyou have the power to:\nChoose Where Your Data Lives: Just like you decide where to place your castle, Pubky Core lets you decide where your information is stored online.\nMove It When Needed: If you have to change where your data is kept (like moving your castle), you can do that easily.\nUpdate the Directions: You can tell everyone where to find your data, so your friends can always access it, no matter where it is.\nWhy is Pubky Core Special?\nYou‚Äôre in Control: You decide where your data is stored on the internet, and you can change it whenever you need to.\nStay Connected Despite Changes: If something happens‚Äîlike censorship or a website blocking you‚Äîyou can move your data to a new place, and people can still find it.\nFreedom to Share: No one can stop you from sharing your stuff. You always have the ability to let others access your data by updating its location.\nIn Simple Terms:\nYou Control the Location of Your Data: Just like moving your castle, you choose where your online information lives.\nAdaptable to Change: If things change or someone tries to stop you, you can move your data and keep sharing without losing anything.\nAlways Accessible: By updating where your data is stored, your friends (or anyone) can always find and see it.\nSo, Pubky Core empowers you to manage where your data is on the internet. It ensures that even if things change‚Äîlike being censored or needing to move‚Äîyou can keep your data accessible and tell others where to find it. It‚Äôs all about you being in control, just like deciding where to set up your favorite toy so your friends can always come and play!"},"Explore/PubkyCore/Homeserver":{"title":"Homeserver","links":["Explore/Concepts/Censorship","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/PubkyApp/Introduction","Explore/Technologies/Homegate","Explore/Concepts/CredibleExit"],"tags":[],"content":"The Pubky network allows multiple, independent data stores, known as ‚Äúhomeservers.‚Äù This improves censorship-resistance and prevents any single entity from controlling the flow of information, or locking people &amp; data in as a walled garden.\nHomeservers are meant to represent a primary place to retrieve data from a specific PKARR public key, but the user can redefine the location of their homeserver at will by updating their PKARR in the Mainline DHT.\nPublic vs Private Data\nCurrent implementations across Pubky currently only support public, unencrypted data use cases. This does not prevent applications from using encrypted data within homeservers, we simply haven‚Äôt implemented that set of features in any direct way yet. Feel free to contribute!\nData Retrieval and Synchronization\n\nAPI: Any service can access data through a RESTful API\n\nDecentralized Storage Architecture\n\nHomeservers can be operated by individuals, cooperatives, or commercial entities, with the option for anonymous operation, promoting a decentralized and resilient storage ecosystem where users could tune their preferred redundancy while maintaining the benefits of a central homeserver.\nWe do not yet have any mirroring or replication tools available yet. Feel free to build with us!\n\nUser Data Control and Credible Exit\n\nThe current network is being bootstrapped by Synonym‚Äôs first homeserver, which supports key accounts as a service, as well as all services required to operate the pubky App.\nWhile Synonym is currently not charging fees for homeserving, it is totally possible for anyone to run their own homerserver and require service fees or peer-to-peer micropayments, or any other requirement, to improve data redundancy and competition.\nHomeserver operators can use Homegate for signup verification, implementing SMS or Lightning Network verification to prevent spam while preserving user privacy.\nSynonym does not control who can join or serve data on the network, but in order to truly have a ‚Äúcredible exit‚Äù the network will need to mature to have more providers of homeservers and Pubky applications.\nWe will also need to make it as easy as possible for people to host their own homeservers, and to host homerserver clouds.\nWe also need to ensure that applications remain performant &amp; reliable as the network fragments.\n\nEvent Stream\nHomeservers expose /events/ and /events-stream endpoints for indexers/aggregators to sync data changes using cursor-based pagination."},"Explore/PubkyCore/Introduction":{"title":"Introduction","links":["Explore/PubkyCore/Pkarr/0.Introduction","Explore/PubkyCore/Homeserver","Explore/Technologies/MainlineDHT","Explore/PubkyCore/Authentication","Explore/Concepts/CredibleExit","Explore/PubkyApp/AppArchitectures/1.Introduction","Explore/PubkyApp/AppArchitectures/2.ClientHomeserver","Explore/PubkyApp/AppArchitectures/3.GlobalAggregators","Explore/PubkyApp/AppArchitectures/4.CustomBackend","Explore/Concepts/SemanticSocialGraph","Explore/PubkyCore/SDK","Explore/PubkyApp/Introduction","Explore/Technologies/PubkyRing","Explore/Technologies/Paykit","Explore/PubkyCore/API","Explore/Technologies/PubkyNoise"],"tags":[],"content":"Pubky Core: Open Protocol for Decentralized Web Applications\n\n\nAn open protocol for per-public-key backends for censorship resistant web applications.\n\nOverview\nPubky Core combines a censorship-resistant public-key-based alternative to DNS (PKARR) with conventional, tried-and-tested web technologies. This keeps users in control of their identities and data while enabling developers to build software with the availability of web apps, without the costs of managing a central database.\nThe Core Philosophy:\n\n‚ÄúThe Web, long centralized, must decentralize; Long decentralized, must centralize.‚Äù\n\nPubky Core provides the infrastructure for building truly decentralized applications where:\n\nUsers control their identities (public keys)\nUsers choose where their data lives (Homeserver)\nApplications remain interoperable\nNo single entity can control or censor\n\nWhat is Pubky Core?\nPubky Core consists of three main components:\n1. Protocol Specification\nThe open protocol that defines:\n\nPublic key-based authentication\nCapability-based authorization\nKey-value storage semantics\nHomeserver discovery via PKARR\nRESTful API standards\n\n2. Homeserver Implementation\nA production-ready server application that:\n\nHosts user data in key-value stores\nProvides RESTful HTTP API\nHandles authentication and sessions\nPublishes to PKARR for discovery\nSupports multiple persistence backends (Files, LMDB, SQL)\nIncludes admin and metrics endpoints\n\n3. SDK (Software Development Kit)\nClient libraries for developers:\n\nRust: Full-featured native SDK\nJavaScript/WASM: Browser and Node.js support\niOS/Android: Native mobile bindings\nExamples and documentation\n\nCore Concepts\nHomeserver\nDecentralized data storage nodes that host user data. Each user can choose their homeserver or run their own. Data is stored per public key, and users can migrate between homeservers by updating their PKARR record.\nPKARR\nSelf-issued public keys that function as sovereign, publicly addressable domains. PKARR records published to the Mainline DHT point to homeserver locations, enabling decentralized discovery.\nAuthentication\nUsers grant apps scoped access to their data on the Homeserver. Authentication is decentralized - users control their own cryptographic keys with no central identity providers.\nCredible Exit\nPubky Core‚Äôs distributed architecture provides user autonomy through credible exit between interchangeable components. Users can switch homeservers, applications, or identity managers without losing their data or social graph.\nKey Features\nAuthentication &amp; Authorization\n\nPublic key-based authentication: No passwords, no accounts\n3rd party authorization: OAuth-style flows with capability tokens\nSession management: Secure, time-limited sessions\nRecovery files: Encrypted backup and recovery\n\nStorage API\n\nKey-value store: Simple PUT/GET/DELETE operations\nHTTP-based: RESTful API over HTTPS\nPagination: Efficient listing of large datasets\nNamespace isolation: Separate data spaces per application\n\nDeveloper Experience\n\nMultiple language bindings: Rust, JavaScript, Swift, Kotlin\nComprehensive examples: Step-by-step tutorials\nTesting utilities: Local testnet for development\nDocker support: Easy deployment and testing\n\nProduction-Ready\n\nMultiple persistence backends: Choose between Files, LMDB, or SQL\nRate limiting: Built-in DDoS protection\nMetrics and monitoring: Prometheus-compatible metrics\nAdmin API: Server management and diagnostics\nEvent streams: Real-time updates via pub/sub\n\nArchitecture\nApplication Architectures\nPubky App Architectures can be very diverse:\n\n\nSimple Client-Homeserver\n\nWeb client connects directly to a single homeserver\nUser data storage and retrieval\nAuthentication and sessions\n\n\n\nGlobal Aggregators\n\nAggregate data from many homeservers\nProvide discovery and search\nEnable social features\n\n\n\nComplex Backends\n\nCustom aggregation and inference\nApplication-specific logic\nEnhanced features like Semantic Social Graph\n\n\n\nData Flow\nUser Identity (Public Key)\n    ‚Üì\nPKARR Record (Mainline DHT)\n    ‚Üì Points to\nHomeserver Location\n    ‚Üì Stores\nUser Data (Key-Value)\n    ‚Üì Accessed by\nApplications (via SDK)\n\nGetting Started\nFor Developers\nInstall SDK:\n# Rust\ncargo add pubky\n \n# JavaScript\nnpm install @synonymdev/pubky\n \n# See mobile bindings in SDK documentation\nQuick Example (JavaScript):\nimport { Pubky } from &#039;@synonymdev/pubky&#039;;\n \n// Create client\nconst pubky = await Pubky.create();\n \n// Sign up (generates keypair)\nconst { publicKey, secretKey } = await pubky.signUp();\n \n// Store data\nawait pubky.put(`/pub/myapp/profile`, JSON.stringify({\n  name: &quot;Alice&quot;,\n  bio: &quot;Decentralized and loving it!&quot;\n}));\n \n// Retrieve data\nconst profile = await pubky.get(`/pub/myapp/profile`);\nSee SDK Documentation for complete guides.\nRun Local Homeserver\nUsing Cargo:\ngit clone github.com/pubky/pubky-core\ncd pubky-core/pubky-homeserver\ncargo run\nUsing Docker:\ndocker build --build-arg TARGETARCH=x86_64 -t pubky:core .\ndocker run --network=host -it pubky:core\nSee Homeserver Documentation for configuration and deployment.\nUse Cases\nSocial Applications\n\nDecentralized social networks (Pubky App)\nBlogging platforms\nComment systems\nForums and communities\n\nData Sovereignty\n\nPersonal data stores\nHealth records\nDocument storage\nFile sharing\n\nIdentity &amp; Authentication\n\nDecentralized identity (Pubky Ring)\nSingle sign-on for web3\nCredential management\n\nPayment Infrastructure\n\nPayment coordination (Paykit)\nSubscription management\nDecentralized commerce\n\nTarget Users\nPubky Core is made for:\n\nDevelopers and builders of internet software products\nStartups building decentralized applications\nOpen-source contributors\nPrivacy-focused services\n\nPubky App is made for:\n\nUsers interested in social media and online publishing\nPeople wanting control over their data\nUsers seeking alternatives to Big Tech platforms\n\nResources\nDocumentation\n\nOfficial Docs: pubky.github.io/pubky-core\nRust API Docs: docs.rs/pubky\nSDK Guide: Complete integration documentation\nAPI Reference: HTTP API specification\nExamples: Rust and JavaScript tutorials in repository\n\nRepositories\n\nMain Repository: github.com/pubky/pubky-core\nNPM Package: @synonymdev/pubky\n\nCommunity\n\nTelegram: t.me/pubkycore\nContributors Guide: See repository\nLicense: MIT\n\nWhy Pubky Core?\nThe Vision\nThe reward for everyone is a more open, privacy-focused, usable, modular, and secure web.\nFor Synonym as lead of this project, the goal is to:\n\nDisrupt Big Tech as an industry\nGain user recognition through building a decentralized ecosystem\nPosition as a major player in online publishing &amp; social media\nMonetize through infrastructure services (similar to Google‚Äôs search/aggregation model)\nIntroduce users to bitcoin payment infrastructure\n\nTechnical Advantages\nvs. Traditional Web Apps:\n\n‚úÖ User controls data location\n‚úÖ No vendor lock-in\n‚úÖ Censorship resistant\n‚úÖ Privacy by default\n\nvs. Blockchain:\n\n‚úÖ No transaction fees\n‚úÖ Instant operations\n‚úÖ Standard web tech\n‚úÖ Scalable storage\n\nvs. P2P Only:\n\n‚úÖ Always available (homeservers)\n‚úÖ Fast access\n‚úÖ Mobile-friendly\n‚úÖ Familiar HTTP APIs\n\nCurrent Status\nProduction Ready:\n\n‚úÖ Homeserver implementation stable\n‚úÖ Rust SDK mature\n‚úÖ JavaScript/WASM bindings stable\n‚úÖ Authentication system complete\n‚úÖ Multiple persistence backends\n\nActive Development:\n\nüöß Mobile native bindings (iOS/Android)\nüöß Event streaming enhancements\nüöß Replication and mirroring tools\nüöß Privacy features (encrypted data)\n\nNeeds Community:\n\nMirroring and replication tools\nMore homeserver providers\nApplication examples\nIntegration libraries\nDocumentation improvements\n\nRelated Technologies\n\nPubky Ring: Identity manager app\nPaykit: Payment protocol (WIP)\nPubky Noise: Encrypted communication (WIP)\nPubky App: Social media application\n\n\nPubky Core provides the foundation for building truly decentralized applications. Join us in creating a more open web!"},"Explore/PubkyCore/Pkarr/0.Introduction":{"title":"0.Introduction","links":["Explore/Technologies/DNS","Explore/Technologies/DHT","Explore/Technologies/PubkyRing","Explore/Technologies/MainlineDHT","Explore/Technologies/HTTPS","Explore/Technologies/DoH","Explore/PubkyCore/Pkarr/4.Architecture","2.Getting-Started-with-Pkarr","Explore/Technologies/PKDNS"],"tags":[],"content":"Public-Key Addressable Resource Records\nPKARR is a revolutionary system that bridges the gap between the Domain Name System (DNS) and peer-to-peer overlay networks. It allows self-issued public keys to function as sovereign, publicly addressable domains. This means that anyone with a private key can have a domain that is accessible to everyone.\nThe core idea is to streamline the process of publishing and resolving resource records for keys, leveraging the Distributed Hash Table (DHT) for efficient and scalable data distribution.\nKey Features\n\nSimplicity: PKARR streamlines the integration between DNS and peer-to-peer networks.\nSovereignty: Public keys can be used as domains, enabling users to maintain control over their digital identities.\nAccessibility: The system is designed to be accessible to anyone capable of maintaining a private key. Pubky Ring provides a user-friendly mobile app for managing these keys securely.\nScalability and Resilience: Designed with scalability and resilience in mind, using the Mainline DHT for storing ephemeral data, and employing caching strategies to minimize DHT traffic.\nCompatibility with Existing Applications: Supports existing applications through DNS over HTTPS (DoH) queries to PKARR servers, ensuring broad compatibility.\n\nHow It Works\n\nPublishing Records: To publish resource records for a key, create a small encoded DNS packet (‚áê 1000 bytes), sign it, and publish it on the DHT. This can be done directly or through a relay if necessary.\nResolving Records: To find resources associated with a key, applications can query the DHT directly or through a relay, verifying the signature themselves.\nFallback for Existing Applications: Applications unaware of PKARR can make normal DNS Queries over HTTPS (DoH) to PKARR servers, ensuring accessibility.\nCaching and Republishing: Both clients and PKARR servers cache records extensively to improve scalability. The DHT drops records after a few hours, necessitating periodic republishing to keep records alive.\n\nFor more technical details on PKARR‚Äôs architecture and how it works, refer to the architecture note.\nGetting Started\nTo start using PKARR, you can visit the web app demo or explore the Rust examples provided in PKARR repository.\nTo access public key domains from your browser, use PKDNS, a DNS server that resolves PKARR records. You can use public PKDNS instances or run your own server‚Äîsee the PKDNS documentation for setup instructions."},"Explore/PubkyCore/Pkarr/1.WhyPkarr":{"title":"Why Pkarr?","links":["Explore/PubkyCore/Pkarr/0.Introduction"],"tags":[],"content":"This note explores the motivation behind PKARR, addressing the challenges of distributed semantics, databases, and discovery.\nIn pursuit of a sovereign, distributed, and open web, we identify three challenges:\n\n\nDistributed Semantics Everything expressed as keys and metadata\nDeveloping interoperable semantics for verifiable metadata about a set of public-keys that form a digital identity, complete with reputation, social graph, credentials, and more.\n\n\nDistributed Database(s) Anyone can host the data\nVerifiable data alone is insufficient; a host-agnostic database is essential for an open web, as opposed to walled gardens.\n\n\nDistributed Discovery Where is the data?\nBut before that, you need to efficiently and consistently discover the multiple hosts for a given data-set.\n\n\nAddressing Distributed Discovery first makes the most sense for several reasons:\n\n\nThe difficulty of these three challenges inversely correlates with their order.\n\n\nThe marginal utility of solving these challenges positively correlates with their order.\nIn existing and emerging open social network protocols, users do tolerate limited interoperability between clients, second-class identifiers controlled by hosting or domain servers, inefficient or non-existent conflict-free replication between data stores, and the absence of local-first or offline support. However, their most common complaints involve unavailability, censorship, deplatforming, and difficulty in securely managing keys.\n\n\nDistributed Discovery offers the greatest assured leverage by abstracting over current and emerging solutions for (1) and (2) as they compete, complement, and develop independently, all while maintaining the same long lasting identifier, so you don‚Äôt have to start from scratch or be locked in.\n\n"},"Explore/PubkyCore/Pkarr/2.GettingStartedWithPkarr":{"title":"Getting Started with Pkarr","links":["Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/DNS","Explore/Technologies/DHT","Explore/Technologies/HTTPS","Explore/Technologies/DoH","Explore/PubkyCore/Pkarr/4.Architecture"],"tags":[],"content":"This guide will help you understand how to publish and resolve resource records using PKARR.\nPublishing Resource Records\nTo publish resource records for your key, you need to sign a small encoded DNS packet (‚áê 1000 bytes) and publish it on the DHT. This can be done through a relay if necessary.\nResolving Resource Records\nTo resolve some key‚Äôs resources, applications can query the DHT directly or through a relay. They will then verify the signature themselves.\nDNS Queries Over HTTPS\nExisting applications unaware of PKARR can make normal DNS Queries over HTTPS (DoH) to PKARR servers.\nCaching and Scalability\nClients and PKARR servers cache records extensively to minimize DHT traffic and improve scalability. The DHT drops records after a few hours, so it‚Äôs important to republish records periodically.\nNext Steps\nFor more technical details on PKARR‚Äôs architecture and how it works, refer to the architecture note."},"Explore/PubkyCore/Pkarr/3.Expectations":{"title":"3.Expectations","links":["Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/DHT","Explore/PubkyCore/Pkarr/1.WhyPkarr"],"tags":[],"content":"Understanding the expectations and limitations of PKARR is crucial for effective use. This note outlines what PKARR is not and what users should expect.\nNot a Storage Platform\nPKARR is not a storage platform. Records are ephemeral and need to be refreshed regularly to remain on the DHT.\nNot a Real-time Communication Medium\nPKARR is not designed for real-time communication. It is optimized for infrequent updates and heavy caching to reduce traffic.\nRate Limiting and Proof of Work\nExpectations include enforcing harsh rate-limiting and possibly demanding proof of work for updates.\nCaching and Propagation Time\nRecords are heavily cached, and updates might take some time to propagate. In case of a cache miss, querying the DHT might take a few seconds.\nNext Steps\nFor a deeper understanding of why PKARR was created and its motivation, refer to the why PKARR? note."},"Explore/PubkyCore/Pkarr/4.Architecture":{"title":"4.Architecture","links":["Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT"],"tags":[],"content":"In-depth look at the architecture of PKARR, including its components and how they interact.\nComponents\n\nClient: Applications or users that publish or query PKARR.\nRelay: Optional intermediary that helps clients behind NAT or firewall to communicate with the Mainline DHT.\nMainline DHT: The peer-to-peer network used to announce and resolve PKARR records.\nRepublisher: Services that keep PKARR alive on the Mainline DHT by periodically republishing them.\n\nInteraction Flow\n\nPublishing: Clients publish PKARR to the Mainline DHT, either directly or through a relay (required for browsers since the DHT uses UDP).\nRepublishing: Homeservers and relays republish records for their users to keep them available on the Mainline DHT.\nQuerying: Clients query the Mainline DHT for PKARR, either directly or through a relay.\n\nKey Technologies\n\nMainline DHT: A global, censorship-resistant p2p network of 10+ million peers. PKARR are announced here using BEP44.\n"},"Explore/PubkyCore/Pkarr/ELI5":{"title":"ELI5","links":[],"tags":[],"content":"ELI5: PKARR with Mainline DHT\nImagine you have a super cool secret club, and everyone in the club needs a way to find each other and communicate without relying on anyone else to organize things. You all have secret codes that tell people who you are, but how do you find where everyone is without a central place telling you?\nThis is where PKARR and Mainline DHT come in.\nPKARR is like a magic address book. Instead of having a central directory, every member of the secret club can create their own identity using special keys, like giving yourself a secret nickname that no one else can copy. With these keys, everyone in the club knows exactly who you are, and they can recognize you by your secret name. But there‚Äôs no single person in charge of this address book‚Äîeveryone has their own copy.\nNow, imagine you want to send messages to your friends, but you don‚Äôt know where they‚Äôre hanging out today. This is where Mainline DHT (Distributed Hash Table) comes in. It‚Äôs like a giant treasure map that the whole club shares, except instead of finding treasure, it tells you where each of your friends are. Mainline DHT helps everyone find each other without needing a central leader. It‚Äôs like everyone working together to keep the map up-to-date so anyone can see where everyone else is, no matter where they are.\n\n\nYour Own Key-Based Identity: PKARR lets you create your own unique identity without needing permission. You can join the network by making your own keys, and these keys make sure that no one can pretend to be you.\n\n\nFinding Friends with DHT: Mainline DHT is how you find other people in the network. It‚Äôs like a shared phone book where everyone adds their own contact info, so anyone can look up where to find you.\n\n\nTogether, PKARR and Mainline DHT mean that everyone in the club can find each other and communicate directly, without relying on any big organization to manage things. It‚Äôs all about keeping control in the hands of the people, making sure everyone can be found when they want to be, and keeping everything open and secure."},"Explore/PubkyCore/SDK":{"title":"SDK","links":["Introduction","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/PubkyCore/Authentication","Explore/Technologies/PubkyRing","Explore/PubkyCore/API"],"tags":[],"content":"Pubky SDK: Client Libraries for Decentralized Applications\nThe Pubky SDK provides client libraries for building applications on Pubky Core. Available in multiple languages with consistent APIs across platforms.\nSupported Platforms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlatformLanguageStatusPackageRustRust‚úÖ Stablecrates.io/crates/pubkyWeb/NodeJavaScript/TypeScript‚úÖ Stable@synonymdev/pubkyReact NativeJavaScript/TypeScript‚úÖ Stable@synonymdev/react-native-pubkyiOSSwiftüöß BetaNative bindingsAndroidKotlinüöß BetaNative bindings\nInstallation\nRust\ncargo add pubky\nJavaScript/TypeScript\nnpm install @synonymdev/pubky\n# or\nyarn add @synonymdev/pubky\nReact Native\nnpm install @synonymdev/react-native-pubky\n# or\nyarn add @synonymdev/react-native-pubky\nFor iOS, also run:\ncd ios &amp;&amp; pod install\niOS\nThe iOS SDK uses native Swift bindings generated via UniFFI. You can either:\nOption 1: Use CocoaPods (Recommended)\npod &#039;PubkyCore&#039;\nOption 2: Build from source\n# Clone the FFI repository\ngit clone github.com/pubky/pubky-core-ffi\ncd pubky-core-ffi\n./build.sh ios\nThe build generates:\n\nbindings/ios/PubkyCore.xcframework - Native framework\nbindings/ios/pubkycore.swift - Swift bindings\n\nSee pubky-core-ffi for detailed integration instructions.\nAndroid\nThe Android SDK uses native Kotlin bindings generated via UniFFI.\nBuild from source:\n# Clone the FFI repository\ngit clone github.com/pubky/pubky-core-ffi\ncd pubky-core-ffi\n./build.sh android\nThe build generates:\n\nbindings/android/jniLibs/ - Native JNI libraries for all architectures\nbindings/android/pubkycore.kt - Kotlin bindings\n\nCopy these to your Android project:\ncp -r bindings/android/jniLibs/* app/src/main/jniLibs/\ncp bindings/android/pubkycore.kt app/src/main/java/\nSee pubky-core-ffi for detailed integration instructions.\nCore Concepts\nPublic Key Identity\nEvery user is identified by an Ed25519 public key:\n\n32-byte public key (encoded as z-base-32)\nCorresponds to a private key held securely by the user\nForms the basis of authentication and data ownership\n\nHomeserver Discovery\nThe SDK uses PKARR to discover where a user‚Äôs data is hosted:\n\nQuery Mainline DHT for public key\nRetrieve PKARR record with homeserver URL\nConnect to homeserver via HTTPS\n\nStorage Paths\nData is organized in a hierarchical namespace:\n/pub/app_name/path/to/data    # Public, readable by anyone\n/private/app_name/secret       # Private (future)\n\nAPI Reference\nClient Creation\nRust:\nuse pubky::PubkyClient;\n \nlet client = PubkyClient::new()?;\nJavaScript:\nimport { Pubky } from &#039;@synonymdev/pubky&#039;;\n \nconst pubky = await Pubky.create();\nSign Up (Generate Identity)\nRust:\nlet keypair = client.signup()?;\nlet public_key = keypair.public_key();\nlet secret_key = keypair.secret_key();\nJavaScript:\nconst { publicKey, secretKey } = await pubky.signUp();\nSign In (Load Existing Identity)\nRust:\nlet secret_key = SecretKey::from_bytes(&amp;secret_bytes)?;\nclient.signin(secret_key)?;\nJavaScript:\nawait pubky.signIn(secretKey);\nStore Data (PUT)\nRust:\nclient.put(\n    &quot;/pub/myapp/profile&quot;,\n    &amp;serde_json::to_vec(&amp;profile)?\n).await?;\nJavaScript:\nawait pubky.put(\n    &quot;/pub/myapp/profile&quot;,\n    JSON.stringify(profile)\n);\nRetrieve Data (GET)\nRust:\nlet data = client.get(&quot;/pub/myapp/profile&quot;).await?;\nlet profile: Profile = serde_json::from_slice(&amp;data)?;\nJavaScript:\nconst data = await pubky.get(&quot;/pub/myapp/profile&quot;);\nconst profile = JSON.parse(data);\nDelete Data (DELETE)\nRust:\nclient.delete(&quot;/pub/myapp/profile&quot;).await?;\nJavaScript:\nawait pubky.delete(&quot;/pub/myapp/profile&quot;);\nList Data (Pagination)\nRust:\nlet entries = client.list(\n    &quot;/pub/myapp/posts/&quot;,\n    Some(ListOptions {\n        limit: Some(20),\n        cursor: None,\n        reverse: false,\n    })\n).await?;\n \nfor entry in entries {\n    println!(&quot;{}: {} bytes&quot;, entry.key, entry.size);\n}\nJavaScript:\nconst entries = await pubky.list(&quot;/pub/myapp/posts/&quot;, {\n    limit: 20,\n    reverse: false\n});\n \nfor (const entry of entries) {\n    console.log(`${entry.key}: ${entry.size} bytes`);\n}\nAuthentication Flows\nThird-Party Authorization\nPubky Core supports OAuth-style authorization for third-party apps:\n// App requests authorization\nlet auth_url = client.request_authorization(\n    &quot;myapp.com/callback&quot;,\n    vec![&quot;read:/pub/&quot;, &quot;write:/pub/myapp/&quot;]\n)?;\n \n// User approves in [[Explore/Technologies/PubkyRing|Pubky Ring]]\n// Callback receives session token\n \n// App uses token for requests\nclient.set_session_token(token)?;\nSee Authentication for the full authentication flow.\nReact Native Usage\nThe React Native SDK (@synonymdev/react-native-pubky) provides the same API as the JavaScript SDK with mobile-optimized bindings built using UniFFI.\nBasic Usage\nimport {\n  signUp,\n  signIn,\n  put,\n  get,\n  list,\n  deleteFile,\n  generateSecretKey,\n  getPublicKeyFromSecretKey\n} from &#039;@synonymdev/react-native-pubky&#039;;\n \n// All methods return Result type\nconst result = await signUp(secretKey, homeserverUrl);\nif (result.isErr()) {\n  console.error(result.error.message);\n  return;\n}\nconsole.log(result.value); // Success value\nSign Up &amp; Authentication\nimport { signUp, signIn, session, getHomeserver } from &#039;@synonymdev/react-native-pubky&#039;;\n \n// Standard signup\nconst signUpRes = await signUp(\n  secretKey,\n  &#039;pubky://8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo&#039;\n);\n \n// Signup with token (for gated homeservers)\nconst signUpWithTokenRes = await signUp(\n  secretKey,\n  &#039;pubky://8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo&#039;,\n  &#039;your_signup_token&#039;\n);\n \n// Sign in\nconst signInRes = await signIn(secretKey);\n \n// Check session\nconst sessionRes = await session(publicKey);\n \n// Get homeserver\nconst homeserverRes = await getHomeserver(publicKey);\nData Operations\nimport { put, get, list, deleteFile } from &#039;@synonymdev/react-native-pubky&#039;;\n \n// Write data\nconst putRes = await put(\n  &#039;pubky://z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty/pub/profile.json&#039;,\n  { data: JSON.stringify({ name: &#039;Alice&#039;, bio: &#039;Builder&#039; }) }\n);\n \n// Read data\nconst getRes = await get(\n  &#039;pubky://z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty/pub/profile.json&#039;\n);\n \n// List directory\nconst listRes = await list(\n  &#039;pubky://z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty/pub/posts/&#039;\n);\n \n// Delete file\nconst deleteRes = await deleteFile(\n  &#039;pubky://z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty/pub/old-post&#039;\n);\nKey Management\nimport { \n  generateSecretKey, \n  getPublicKeyFromSecretKey,\n  createRecoveryFile,\n  decryptRecoveryFile\n} from &#039;@synonymdev/react-native-pubky&#039;;\n \n// Generate new key pair\nconst keyRes = await generateSecretKey();\nconst secretKey = keyRes.value;\n \n// Derive public key\nconst pubKeyRes = await getPublicKeyFromSecretKey(secretKey);\nconst publicKey = pubKeyRes.value;\n \n// Create encrypted recovery file\nconst recoveryRes = await createRecoveryFile(secretKey, &#039;passphrase&#039;);\nconst recoveryFile = recoveryRes.value; // Base64 encoded\n \n// Decrypt recovery file\nconst decryptRes = await decryptRecoveryFile(recoveryFile, &#039;passphrase&#039;);\nconst recoveredKey = decryptRes.value;\nHTTPS Resolution\nimport { resolveHttps } from &#039;@synonymdev/react-native-pubky&#039;;\n \n// Resolve public key to HTTPS URL\nconst resolveRes = await resolveHttps(\n  &#039;z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty&#039;\n);\n \nif (resolveRes.isOk()) {\n  console.log(`HTTPS URL: ${resolveRes.value}`);\n}\nExample: Complete Social Profile\nimport { signUp, put, get } from &#039;@synonymdev/react-native-pubky&#039;;\n \n// Sign up\nconst signUpRes = await signUp(secretKey, homeserverUrl);\nif (signUpRes.isErr()) throw new Error(signUpRes.error.message);\n \n// Create profile (following pubky-app-specs)\nconst profile = {\n  name: &#039;Alice&#039;,\n  bio: &#039;Building on Pubky&#039;,\n  image: &#039;pubky://alice-pubkey/pub/profile.jpg&#039;,\n  links: [\n    { title: &#039;Website&#039;, url: &#039;alice.com&#039; }\n  ]\n};\n \n// Write profile\nconst putRes = await put(\n  &#039;pubky://alice-pubkey/pub/pubky.app/profile.json&#039;,\n  { data: JSON.stringify(profile) }\n);\n \n// Read profile\nconst getRes = await get(&#039;pubky://alice-pubkey/pub/pubky.app/profile.json&#039;);\nconst savedProfile = JSON.parse(getRes.value);\nRepository &amp; Documentation\n\nNPM: @synonymdev/react-native-pubky\nGitHub: github.com/pubky/react-native-pubky\nExamples: Example App\n\nExamples\nSimple Profile Storage\nimport { Pubky } from &#039;@synonymdev/pubky&#039;;\n \nasync function storeProfile() {\n    const pubky = await Pubky.create();\n    \n    // Generate identity\n    const { publicKey, secretKey } = await pubky.signUp();\n    console.log(`Public Key: ${publicKey}`);\n    \n    // Sign in\n    await pubky.signIn(secretKey);\n    \n    // Store profile (following pubky-app-specs format)\n    const profile = {\n        name: &quot;Alice&quot;,\n        bio: &quot;Building on Pubky&quot;,\n        image: &quot;pubky://user_id/pub/pubky.app/files/0000000000000&quot;,\n        links: [\n            {\n                title: &quot;GitHub&quot;,\n                url: &quot;github.com/alice&quot;\n            }\n        ],\n        status: &quot;Exploring decentralized tech.&quot;\n    };\n    \n    // Store at standard pubky-app location\n    await pubky.put(\n        &quot;/pub/pubky.app/profile.json&quot;,\n        JSON.stringify(profile)\n    );\n    \n    console.log(&quot;Profile stored!&quot;);\n    \n    // Retrieve profile\n    const data = await pubky.get(&quot;/pub/pubky.app/profile.json&quot;);\n    const retrieved = JSON.parse(data);\n    console.log(&quot;Retrieved:&quot;, retrieved);\n}\nNote: This example follows the pubky-app-specs data model specification for interoperability with Pubky App ecosystem.\nSocial Feed Application\nuse pubky::{PubkyClient, ListOptions};\nuse serde::{Deserialize, Serialize};\n \n#[derive(Serialize, Deserialize)]\nstruct Post {\n    content: String,\n    timestamp: i64,\n    author: String,\n}\n \nasync fn publish_post(client: &amp;PubkyClient, post: &amp;Post) -&gt; anyhow::Result&lt;()&gt; {\n    let post_id = post.timestamp.to_string();\n    let path = format!(&quot;/pub/social/posts/{}&quot;, post_id);\n    \n    client.put(&amp;path, &amp;serde_json::to_vec(post)?).await?;\n    Ok(())\n}\n \nasync fn get_feed(client: &amp;PubkyClient, public_key: &amp;str) -&gt; anyhow::Result&lt;Vec&lt;Post&gt;&gt; {\n    let path = format!(&quot;pubky://{}/pub/social/posts/&quot;, public_key);\n    \n    let entries = client.list(&amp;path, Some(ListOptions {\n        limit: Some(50),\n        reverse: true, // Newest first\n        cursor: None,\n    })).await?;\n    \n    let mut posts = Vec::new();\n    for entry in entries {\n        let data = client.get(&amp;entry.key).await?;\n        let post: Post = serde_json::from_slice(&amp;data)?;\n        posts.push(post);\n    }\n    \n    Ok(posts)\n}\nComplete Examples\nThe repository includes comprehensive examples:\nJavaScript Examples:\n\n0-logging.mjs - Setup and logging\n1-testnet.mjs - Local testnet\n2-signup.mjs - Identity creation\n3-authenticator.mjs - Auth flow\n4-storage.mjs - CRUD operations\n5-request.mjs - Authorization\n\nRust Examples:\n\n0-logging - Setup and logging\n1-testnet - Local testnet\n2-signup - Identity creation\n3-auth_flow - Complete auth\n4-storage - CRUD operations\n5-request - Authorization\n6-auth_flow_signup - Full signup flow\n\nTesting\nLocal Testnet\nFor development, run a local homeserver:\n# Clone repository\ngit clone github.com/pubky/pubky-core\ncd pubky-core\n \n# Run testnet\ncargo run --bin pubky-testnet\nThen connect your app to http://localhost:15411.\nJavaScript:\nimport { Pubky } from &#039;@synonymdev/pubky&#039;;\n \nconst pubky = await Pubky.create({\n    homeserverUrl: &#039;http://localhost:15411&#039;\n});\nUnit Tests\nJavaScript:\ncd pubky-sdk/bindings/js\nnpm run testnet  # Start local server\nnpm test         # Run tests\nRust:\ncd pubky-sdk\ncargo test\nAdvanced Features\nSession Management\n// Create session with capabilities\nlet session = client.create_session(vec![\n    &quot;read:/pub/&quot;,\n    &quot;write:/pub/myapp/&quot;\n])?;\n \n// Use session token\nclient.set_session_token(session.token)?;\n \n// Refresh session\nclient.refresh_session().await?;\nRecovery Files\n// Export recovery file (encrypted)\nlet recovery_data = client.export_recovery(&quot;password&quot;)?;\nstd::fs::write(&quot;recovery.dat&quot;, recovery_data)?;\n \n// Import recovery file\nlet recovery_data = std::fs::read(&quot;recovery.dat&quot;)?;\nclient.import_recovery(&amp;recovery_data, &quot;password&quot;)?;\nMultiple Identities\nlet client1 = PubkyClient::new()?;\nclient1.signin(secret_key_1)?;\n \nlet client2 = PubkyClient::new()?;\nclient2.signin(secret_key_2)?;\n \n// Each client maintains separate identity\nPlatform-Specific Notes\niOS Integration\nimport PubkySDK\n \nlet client = PubkyClient()\nlet keypair = try await client.signUp()\nprint(&quot;Public Key: \\(keypair.publicKey)&quot;)\n \ntry await client.put(\n    path: &quot;/pub/myapp/data&quot;,\n    data: jsonData\n)\nAndroid Integration\nimport pubky.PubkyClient\n \nval client = PubkyClient()\nval keypair = client.signUp()\nprintln(&quot;Public Key: ${keypair.publicKey}&quot;)\n \nclient.put(\n    path = &quot;/pub/myapp/data&quot;,\n    data = jsonData\n)\nError Handling\nRust:\nuse pubky::PubkyError;\n \nmatch client.get(&quot;/pub/myapp/data&quot;).await {\n    Ok(data) =&gt; println!(&quot;Retrieved: {:?}&quot;, data),\n    Err(PubkyError::NotFound) =&gt; println!(&quot;Data not found&quot;),\n    Err(PubkyError::Unauthorized) =&gt; println!(&quot;Not authorized&quot;),\n    Err(e) =&gt; eprintln!(&quot;Error: {}&quot;, e),\n}\nJavaScript:\ntry {\n    const data = await pubky.get(&quot;/pub/myapp/data&quot;);\n    console.log(&quot;Retrieved:&quot;, data);\n} catch (error) {\n    if (error.code === &#039;NOT_FOUND&#039;) {\n        console.log(&quot;Data not found&quot;);\n    } else if (error.code === &#039;UNAUTHORIZED&#039;) {\n        console.log(&quot;Not authorized&quot;);\n    } else {\n        console.error(&quot;Error:&quot;, error.message);\n    }\n}\nBest Practices\n\n\nSecure Key Storage: Never store private keys in plaintext\n\niOS: Use Keychain Services\nAndroid: Use EncryptedSharedPreferences\nWeb: Use secure storage APIs or Pubky Ring\n\n\n\nSession Management: Use time-limited sessions, refresh regularly\n\n\nError Handling: Always handle network errors and retries\n\n\nRate Limiting: Respect homeserver rate limits\n\n\nData Validation: Validate data before storing and after retrieving\n\n\nNamespacing: Use consistent path structures per application\n\n\nResources\n\nRust API Docs: docs.rs/pubky\nRepository: github.com/pubky/pubky-core\nNPM Package: @synonymdev/pubky\nReact Native Package: @synonymdev/react-native-pubky\nReact Native Repository: github.com/pubky/react-native-pubky\niOS/Android FFI: github.com/pubky/pubky-core-ffi - Native bindings via UniFFI\nExamples: github.com/pubky/pubky-core/tree/main/examples\nPubky Core Overview: Main documentation\nAPI Reference: HTTP API specification\n\n\nThe Pubky SDK makes it easy to build decentralized applications with standard web technologies."},"Explore/PubkyCore/index":{"title":"Pubky Core","links":["Explore/PubkyCore/Introduction","Explore/PubkyCore/API","Explore/PubkyCore/SDK","Explore/PubkyCore/Authentication","Explore/PubkyCore/Homeserver","Explore/PubkyCore/Pkarr/0.Introduction"],"tags":[],"content":"\nIntroduction\nAPI\nSDK\nAuthentication\nHomeserver\nPkarr\n"},"Explore/Technologies/DHT":{"title":"DHT","links":["Explore/Technologies/MainlineDHT","Explore/Concepts/Censorship"],"tags":[],"content":"Distributed Hash Table\nIt is a decentralized key-value store that allows for efficient data retrieval in a distributed system. Unlike traditional databases, DHTs do not rely on a central server to manage data. Instead, they use a hash function to map keys to nodes in the network, enabling data to be stored and retrieved across multiple nodes.\nA relevant example of DHT for Pubky is the Mainline DHT that is used primarily by the BitTorrent Network.\nKey Features\n\n\nDecentralization: DHTs operate without a central authority, making them highly resilient to failures and censorship.\n\n\nScalability: They can easily scale to accommodate more data and users by adding more nodes to the network.\n\n\nEfficiency: By distributing data across multiple nodes, DHTs can provide fast access to data without the need for a central server.\n\n\nApplications\nDHTs are widely used in various applications, including:\n\n\nP2P Networks: They are the backbone of peer-to-peer (P2P) networks, enabling the sharing of files and resources among users.\n\n\nContent Delivery Networks (CDNs): DHTs help in efficiently distributing content across a global network of servers, improving load balancing and reducing latency.\n\n\nChallenges\nDespite their advantages, DHTs face several challenges, including:\n\n\nSecurity: Ensuring data privacy and integrity in a decentralized environment.\n\n\nConsistency: Achieving consistency across the distributed network, especially in the presence of node failures or network partitions.\n\n\nPerformance: Balancing the trade-off between data distribution and access latency.\n\n\nDHTs represent a significant advancement in distributed systems, offering a scalable and efficient solution for data storage and retrieval in decentralized environments."},"Explore/Technologies/DNS":{"title":"DNS","links":["Explore/Technologies/PKDNS","Explore/Technologies/MainlineDHT","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/DoH","Explore/PubkyCore/Homeserver","Explore/Technologies/HTTPS"],"tags":[],"content":"Domain Name System (DNS)\nThe Domain Name System (DNS) is a hierarchical and distributed naming system that translates human-readable domain names (e.g., www.example.com) into IP addresses (e.g., 192.0.2.1) that computers use to identify each other on the network. This process simplifies internet navigation by allowing users to access websites using memorable names instead of numerical addresses.\nHow DNS Works\nWhen you enter a domain name in your browser, a multi-step lookup process occurs:\n\nQuery Initiation: Your device checks its local DNS cache for the IP address\nRecursive Resolver: If not cached, the query goes to a recursive DNS resolver (usually provided by your ISP)\nRoot Nameserver: The resolver queries a root nameserver to find the TLD (Top Level Domain) nameserver\nTLD Nameserver: The TLD nameserver (e.g., for .com) directs to the authoritative nameserver\nAuthoritative Nameserver: This server returns the IP address for the requested domain\nResponse: The IP address is returned to your device and cached for future use\n\nThis hierarchical system enables billions of domain names to be resolved efficiently across the internet.\nDNS Record Types\nDNS supports multiple record types, each serving different purposes:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecord TypePurposeExampleAMaps domain to IPv4 addressexample.com ‚Üí 192.0.2.1AAAAMaps domain to IPv6 addressexample.com ‚Üí 2001:db8::1CNAMECanonical name (alias)www.example.com ‚Üí example.comTXTText records for verificationSPF, DKIM, domain verificationMXMail exchange serversEmail routingNSNameserver recordsDelegates subdomain to nameserverHTTPSHTTPS service bindingModern service configurationSVCBService bindingGeneric service endpoints\nCentralization and Control Issues\nTraditional DNS has fundamental limitations:\n1. Centralized Control\n\nICANN governance: A single organization controls the root zone\nRegistrar dependency: You rent domain names, never truly own them\nPayment required: Annual fees to maintain domains\nRevocable: Domains can be seized or suspended\n\n2. Censorship Vulnerability\n\nDNS filtering: Governments and ISPs can block domain resolution\nSelective blocking: Easy to censor specific sites\nSurveillance: DNS queries reveal browsing activity\nSingle point of failure: Attacking DNS infrastructure impacts accessibility\n\n3. Privacy Concerns\n\nUnencrypted queries: Traditional DNS (port 53) sends queries in plaintext\nActivity tracking: ISPs and intermediaries can monitor all DNS requests\nData harvesting: DNS providers can collect and monetize query data\n\nWhy PKDNS is Needed\nPKDNS addresses these limitations by creating a decentralized, censorship-resistant alternative:\n\nSelf-sovereign domains: Your public key IS your domain - no registration, no rent\nNo central authority: Uses Mainline DHT instead of ICANN hierarchy\nCensorship resistant: Distributed across millions of nodes, impossible to block\nTrue ownership: You control your identity and domain through cryptographic keys\nPrivacy: No centralized entity tracks your DNS queries\n\nPKDNS bridges the gap between traditional DNS and the decentralized web, enabling PKARR records to function as domains while maintaining compatibility with existing infrastructure.\nSecurity Considerations\nTraditional DNS Security Issues\n\nDNS Spoofing: Attackers can provide false DNS responses\nCache Poisoning: Malicious data injected into DNS caches\nMan-in-the-Middle: Unencrypted queries can be intercepted\nDDoS Attacks: DNS servers are frequent targets\n\nModern DNS Security Solutions\n\nDNSSEC: Cryptographic signatures verify DNS responses (but doesn‚Äôt encrypt queries)\nDNS over HTTPS: Encrypts DNS queries to prevent surveillance\nDNS over TLS (DoT): Similar encryption using TLS protocol\nEncrypted SNI: Hides the domain name during TLS handshake\n\nPKDNS Security Model\nPKDNS provides superior security through:\n\nCryptographic authentication: All records are signed with private keys\nDistributed verification: Anyone can verify signatures independently\nNo trust required: Eliminates need to trust centralized authorities\nResilient infrastructure: Distributed across DHT nodes, no single point of failure\n\nDNS in the Pubky Ecosystem\nPubky uses DNS technology in innovative ways:\n\nPKDNS: DNS server that resolves public key domains from PKARR records\nHybrid approach: Supports both traditional ICANN domains and public key domains\nDoH integration: Provides encrypted DNS resolution\nHomeserver discovery: PKARR records contain DNS-like entries pointing to homeservers\n\nSee Also\n\nPKDNS: Public key DNS implementation\nPKARR: Public key addressable resource records\nMainline DHT: Distributed hash table powering PKDNS\nDoH: DNS over HTTPS for encrypted queries\nHTTPS: Secure HTTP protocol\n"},"Explore/Technologies/DoH":{"title":"DoH","links":["Explore/Technologies/DNS","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/HTTPS"],"tags":[],"content":"DNS over HTTPS\nIt is a security protocol that encrypts DNS queries and responses, enhancing privacy and security by preventing eavesdropping and tampering. In the context of PKARR, DoH plays a crucial role in ensuring that DNS queries made to resolve public-key addresses are secure and cannot be intercepted or manipulated by third parties.\nKey Points about DoH\n\n\nEncryption: DoH encrypts DNS traffic, making it unreadable to anyone who might intercept the data. This is achieved by sending DNS queries and responses over HTTPS connections, utilizing port 443, the standard port for HTTPS traffic.\n\n\nPrivacy and Security: By encrypting DNS queries, DoH significantly increases privacy and security. It prevents Internet Service Providers (ISPs), governments, and hackers from monitoring or altering DNS requests.\n\n\nStandardization and Adoption: DoH has been adopted by major internet brands, including Apple, Microsoft, and Google, to enhance online security. It was first implemented by Mozilla in 2018, and since then, it has become a standard for secure DNS communication.\n\n\nCompatibility and Implementation: DoH can be enabled in browsers and operating systems, allowing users to benefit from its privacy and security features. However, it‚Äôs important to ensure compatibility with existing cybersecurity solutions, as enabling DoH might impact DNS traffic filtering tools.\n\n"},"Explore/Technologies/HTTPS":{"title":"HTTPS","links":["Explore/Technologies/DNS"],"tags":[],"content":"Hypertext Transfer Protocol Secure\nIt is an extension of HTTP that encrypts communication over a computer network, enhancing security and privacy. It uses TLS (Transport Layer Security) or SSL (Secure Sockets Layer) for encryption, protecting against eavesdropping and tampering. HTTPS is essential for securely transmitting sensitive data, such as login credentials and financial transactions, ensuring the authenticity of websites and the privacy of user communications.\nKey Features\n\n\nEncryption: Secures data in transit using TLS/SSL, making it unreadable to interceptors.\n\n\nAuthentication: Verifies the identity of websites and services using digital certificates, ensuring users are communicating with the intended party.\n\n\nProtection: Guards against man-in-the-middle attacks and DNS spoofing, safeguarding user data and privacy.\n\n"},"Explore/Technologies/Homegate":{"title":"Homegate","links":["Explore/PubkyCore/Homeserver","FAQ","Explore/PubkyCore/SDK","Explore/PubkyCore/Introduction","Explore/Concepts/Censorship"],"tags":[],"content":"Homegate: Homeserver Signup Gatekeeping Service\nHomegate is a backend service that manages and controls signups for Pubky Homeservers. It provides verification mechanisms to prevent spam and abuse while preserving user privacy, implementing both SMS verification and Lightning Network payment verification for homeserver access.\nOverview\nWhen operating a public homeserver, spam prevention is critical. Homegate acts as a gatekeeper, requiring users to prove their authenticity before gaining access to create accounts on a homeserver. Unlike traditional centralized signup systems, Homegate is designed to:\n\nPrevent spam: Rate-limit signups per phone number or require economic commitment via Lightning payments\nPreserve privacy: Use cryptographic hashing (Argon2id with Blake3 pepper) to protect phone number privacy\nRemain optional: Homeserver operators can choose to use Homegate, implement their own solution, or allow open signups\nSupport multiple verification methods: SMS codes or Lightning Network payments\n\nUse Case\nHomegate solves the problem expressed in Q37: ‚ÄúHow do users join Pubky App? Via invite codes from homeservers. Prevents spam while preserving privacy.‚Äù\nWhile the FAQ mentions ‚Äúinvite codes,‚Äù Homegate implements a more sophisticated system using:\n\nSMS verification: Send a code to a phone number, verify ownership\nLightning payment verification: Generate a BOLT11 invoice, verify payment\n\nArchitecture\nComponents\nHTTP API Server (axum):\n\nRESTful endpoints for verification flows\nOpenAPI specification for API documentation\nCORS support for browser-based clients\nRequest origin tracking for abuse prevention\n\nSMS Verification Service:\n\nIntegration with Prelude SMS provider\nRate limiting per phone number (weekly/annual limits)\nCryptographic phone number hashing for privacy\nSession reuse for pending verifications\n\nLightning Network Verification Service:\n\nIntegration with PhoenixD Lightning node\nBOLT11 invoice generation\nReal-time payment tracking via WebSocket\nBackground payment synchronization\n\nDatabase Layer (PostgreSQL + SQLx):\n\nVerification request tracking\nRate limit enforcement\nPayment status management\nMigration system for schema evolution\n\nSecurity Layer:\n\nArgon2id password hashing for phone numbers\nBlake3-based pepper stored securely on disk\nPer-IP rate limiting\nUser-agent tracking\n\nTechnology Stack\n\nLanguage: Rust\nWeb Framework: Axum 0.8\nDatabase: PostgreSQL via SQLx\nSMS Provider: Prelude API\nLightning: PhoenixD via HTTP + WebSocket APIs\nCryptography: Argon2id (hashing), Blake3 (pepper)\n\nVerification Methods\nSMS Verification\nUsers verify phone number ownership by receiving and entering a verification code.\nFlow\n\n\nRequest Code: POST /sms_verification/send_code\n\nSubmit phone number in E.164 format (e.g., +30123456789)\nService checks rate limits (default: 2/week, 4/year per number)\nCreates Prelude verification session\nSends SMS code to phone number\n\n\n\nVerify Code: POST /sms_verification/verify_code\n\nSubmit phone number and 6-digit code\nService validates code with Prelude\nReturns success/failure\n\n\n\nGet Status: GET /sms_verification/status/{phone_number}\n\nCheck if phone number is verified\nReturns verification state\n\n\n\nRate Limits\nConfigurable per homeserver deployment:\n\nWeekly limit: HG_MAX_SMS_VERIFICATIONS_PER_WEEK (default: 2)\nAnnual limit: HG_MAX_SMS_VERIFICATIONS_PER_YEAR (default: 4)\n\nThese limits prevent:\n\nPhone number farming\nBulk account creation\nVerification code abuse\n\nPrivacy Protection\nPhone numbers are never stored in plaintext:\n\nBlake3 Pepper: Secret value generated on first run, stored at /.homegate/pepper.txt\nArgon2id Hashing: Phone number + pepper ‚Üí cryptographic hash\nDatabase Storage: Only hash is stored, not original phone number\n\n‚ö†Ô∏è Critical: If pepper.txt is lost, existing verifications cannot be matched to new requests, breaking rate limit enforcement.\nSession Reuse\nMultiple send_code requests for the same phone number reuse the existing Prelude session:\n\nPrevents SMS flooding\nReduces costs for homeserver operators\nUser can request code resend without creating new session\n\nLightning Network Verification\nUsers verify economic commitment by paying a Lightning Network invoice.\nFlow\n\n\nCreate Verification: POST /ln_verification\n\nOptional amount and description\nService generates BOLT11 invoice via PhoenixD\nReturns verification ID and invoice string\n\n\n\nCheck Status: GET /ln_verification/{verification_id}\n\nCheck current payment status\nReturns: pending, paid, expired, or failed\n\n\n\nAwait Payment: GET /ln_verification/{verification_id}/await\n\nLong-polling endpoint (30s timeout)\nWaits for payment confirmation\nReturns immediately if already paid\n\n\n\nBackground Sync: Continuous WebSocket connection to PhoenixD\n\nMonitors all incoming payments in real-time\nUpdates verification status automatically\nHandles reconnections and error recovery\n\n\n\nPayment Amounts\nConfigurable by homeserver operator:\n\nMinimum amount: Prevent dust attacks\nDefault amount: Balance between accessibility and spam prevention\nCustom amounts: Allow users to pay more for priority, donations, etc.\n\nEconomic Anti-Spam\nLightning payments provide natural spam resistance:\n\nCost per signup: Makes bulk account creation expensive\nInstant verification: No waiting for confirmations\nPrivacy-preserving: No personal information required\nCensorship-resistant: Lightning Network is permissionless\n\nAPI Reference\nSMS Verification Endpoints\nSend Verification Code\nPOST /sms_verification/send_code\nContent-Type: application/json\n \n{\n  &quot;phoneNumber&quot;: &quot;+30123456789&quot;\n}\nResponses:\n\n200 OK: Code sent successfully\n400 Bad Request: Invalid phone number format\n429 Too Many Requests: Rate limit exceeded\n500 Internal Server Error: SMS service failure\n\nVerify Code\nPOST /sms_verification/verify_code\nContent-Type: application/json\n \n{\n  &quot;phoneNumber&quot;: &quot;+30123456789&quot;,\n  &quot;code&quot;: &quot;123456&quot;\n}\nResponses:\n\n200 OK: Code verified successfully\n400 Bad Request: Invalid code\n404 Not Found: No pending verification\n410 Gone: Verification expired\n\nGet Status\nGET /sms_verification/status/{phoneNumber}\nResponses:\n\n200 OK: Returns JSON with verification status\n404 Not Found: Phone number not verified\n\nLightning Network Endpoints\nCreate Verification\nPOST /ln_verification\nContent-Type: application/json\n \n{\n  &quot;amountSat&quot;: 1000,\n  &quot;description&quot;: &quot;Homeserver signup verification&quot;\n}\nResponse (200 OK):\n{\n  &quot;verificationId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,\n  &quot;invoice&quot;: &quot;lnbc10n1...&quot;,\n  &quot;amountSat&quot;: 1000,\n  &quot;expiresAt&quot;: &quot;2025-01-05T12:00:00Z&quot;\n}\nGet Verification Status\nGET /ln_verification/{verificationId}\nResponse (200 OK):\n{\n  &quot;verificationId&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;,\n  &quot;status&quot;: &quot;paid&quot;,\n  &quot;amountSat&quot;: 1000,\n  &quot;paidAt&quot;: &quot;2025-01-05T11:30:00Z&quot;\n}\nStatus values: pending, paid, expired, failed\nAwait Payment\nGET /ln_verification/{verificationId}/await\nLong-polling endpoint that waits up to 30 seconds for payment:\n\nReturns immediately if already paid\nTimes out after 30s if still pending\nClient should retry if timeout occurs\n\nDeployment\nPrerequisites\n\nPostgreSQL database\nPrelude API account (for SMS)\nPhoenixD Lightning node (for Lightning payments)\nRust toolchain (for building from source)\n\nConfiguration\nSet environment variables (see .env.example in repository):\n# Database\nDATABASE_URL=postgres://user:pass@localhost:5432/homegate\n \n# Prelude SMS\nPRELUDE_API_KEY=your_prelude_api_key\nPRELUDE_PROJECT_ID=your_project_id\n \n# PhoenixD Lightning\nPHOENIXD_URL=http://localhost:9740\nPHOENIXD_PASSWORD=your_phoenixd_password\n \n# Rate Limits (optional)\nHG_MAX_SMS_VERIFICATIONS_PER_WEEK=2\nHG_MAX_SMS_VERIFICATIONS_PER_YEAR=4\n \n# Server\nHG_PORT=8080\nHG_HOST=0.0.0.0\nRunning\nDevelopment\n# Clone repository\ngit clone github.com/pubky/homegate\ncd homegate\n \n# Set up environment\ncp .env.example .env\n# Edit .env with your credentials\n \n# Run database migrations\ncargo run -- migrate\n \n# Start server\ncargo run\nProduction\n# Build release binary\ncargo build --release\n \n# Run migrations\n./target/release/homegate migrate\n \n# Start service\n./target/release/homegate serve\nDocker\n# Build image\ndocker build -t homegate .\n \n# Run with environment\ndocker run -d \\\n  --name homegate \\\n  -p 8080:8080 \\\n  --env-file .env \\\n  homegate\nDatabase Migrations\nHomegate uses SQLx for database migrations:\n# Run all pending migrations\ncargo run -- migrate\n \n# Create new migration\nsqlx migrate add create_new_table\n \n# Rollback last migration (if supported)\ncargo run -- migrate revert\nMigrations are located in src/infrastructure/sql/migrations/.\nCritical: Pepper Security\nOn first run, Homegate generates a pepper file at /.homegate/pepper.txt:\n‚ö†Ô∏è BACKUP THIS FILE\nIf lost:\n\nCannot match existing phone number hashes to new verification requests\nRate limits will not be enforced correctly\nExisting verified users may be unable to re-verify\n\nSecurity recommendations:\n\nStore pepper in encrypted backup\nRestrict file permissions (chmod 600)\nInclude in disaster recovery plan\nNever commit to version control\n\nIntegration with Homeservers\nHomegate is designed to integrate with Pubky Homeserver signup flows:\nTypical Integration\n\nUser initiates signup on homeserver web interface\nHomeserver redirects to Homegate verification flow\nUser completes verification (SMS or Lightning)\nHomegate returns success to homeserver\nHomeserver creates account using Pubky Core SDK\n\nVerification Token Flow\nAfter successful verification, Homegate can issue a signed token:\n\nHomeserver verifies token signature\nToken contains verification method, timestamp, rate limit info\nPrevents verification bypass attacks\n\nSelf-Hosted vs. Shared\nSelf-Hosted Homegate:\n\nFull control over verification policies\nCustom rate limits\nPrivate SMS/Lightning credentials\nIsolated user base\n\nShared Homegate:\n\nMultiple homeservers share one Homegate instance\nCentralized rate limiting across homeservers\nReduced operational overhead\nShared anti-spam database\n\nTesting\nUnit Tests\n# Test individual components\ncargo test --lib\nIntegration Tests\n# Requires PostgreSQL\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/homegate_test \\\n  cargo test\nE2E HTTP Tests\n# Full HTTP integration tests with mocked SMS/Lightning\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/homegate_test \\\n  cargo test --lib e2e::\nTest structure:\n\nUnit tests: IP extraction, hashing logic\nService tests: Business logic, database operations\nE2E tests: Full HTTP flows with WireMock for external APIs\n\nUse Cases\nPublic Homeserver Operation\nRun a public homeserver with spam protection:\n\nRequire SMS verification for all signups\nRate limit accounts per phone number\nPreserve user privacy with hashed identifiers\n\nLightning-Gated Community\nCreate a homeserver requiring payment for access:\n\nSet minimum Lightning payment amount\nImmediate verification upon payment\nNo personal information required\nDonations support homeserver operation\n\nHybrid Verification\nOffer users a choice:\n\nSMS verification (free, but rate-limited)\nLightning payment (instant, any amount)\nDifferent verification levels for different features\n\nRegional Homeserver\nOperate a homeserver for specific region:\n\nSMS verification validates phone number locality\nRate limits prevent cross-border spam\nLightning fallback for international users\n\nDevelopment/Testing\nRun a homeserver for development:\n\nLow Lightning payment amounts (1 sat)\nRelaxed SMS rate limits\nEasy cleanup between test runs\n\nOperational Considerations\nCosts\nSMS Verification:\n\nPrelude charges per SMS sent\nTypical cost: $0.01-0.10 per SMS (varies by country)\nRate limits reduce cost exposure\n\nLightning Verification:\n\nPhoenixD requires Lightning node operation\nIncoming payments incur routing fees (~1%)\nChannel liquidity management\nOn-chain fees for channel opens/closes\n\nReliability\nSMS Dependencies:\n\nPrelude API uptime\nInternational SMS delivery reliability\nPhone number portability issues\n\nLightning Dependencies:\n\nPhoenixD node uptime\nLightning Network routing reliability\nChannel liquidity availability\nWebSocket connection stability\n\nScalability\nDatabase:\n\nPostgreSQL handles millions of verifications\nIndex on phone number hashes for performance\nRegular cleanup of expired verifications\n\nSMS Service:\n\nPrelude scales automatically\nConsider multiple SMS providers for redundancy\n\nLightning Service:\n\nPhoenixD requires channel capacity monitoring\nAutomated channel rebalancing recommended\nConsider Lightning Service Provider (LSP) for larger scale\n\nPrivacy\nSMS Verification:\n\nPhone numbers hashed before storage\nPepper protects against rainbow tables\nArgon2id makes brute-force infeasible\nNo plaintext phone numbers in logs\n\nLightning Verification:\n\nNo personal information collected\nPayment amounts are visible on Lightning Network\nInvoice descriptions should not contain PII\nPayment hashes cannot be linked to users without invoices\n\nSecurity Considerations\nThreat Model\nAttacks Homegate Prevents:\n\nBulk account creation via SMS farming\nPhone number enumeration attacks\nVerification code brute-forcing\nRate limit bypass attempts\n\nAttacks Homegate Does NOT Prevent:\n\nStolen phone numbers (SIM swapping)\nStolen Lightning payments (compromised wallets)\nSophisticated adversaries with large phone number pools\nState-level phone number access\n\nBest Practices\n\nRotate pepper periodically (with migration strategy)\nMonitor rate limit patterns for abuse\nSet up alerts for SMS/Lightning service failures\nRegular database backups including pepper file\nRate limit per IP in addition to per phone number\nLog verification attempts for abuse analysis\nUse HTTPS for all API endpoints\nValidate all input (phone numbers, codes, amounts)\n\nLimitations\nPhone Number Verification\n\nSMS delivery: Not guaranteed in all countries\nPhone number recycling: Old numbers may be reassigned\nVoIP numbers: May not receive SMS\nRate limit bypass: Users with multiple phone numbers\nCost: SMS fees add up for high-volume homeservers\n\nLightning Network Verification\n\nTechnical barrier: Users need Lightning wallet\nLiquidity: Homeserver needs sufficient inbound liquidity\nNetwork fees: May exceed verification amount for small payments\nUX complexity: More steps than SMS for non-technical users\nVolatility: Sat amounts may need adjustment based on BTC price\n\nGeneral\n\nNot a complete KYC solution: Verifies possession, not identity\nPrivacy vs. abuse trade-off: Better privacy = easier to abuse\nCentralization risk: SMS provider is single point of failure\nPepper loss: Unrecoverable without backups\n\nFuture Enhancements\nPotential improvements for Homegate:\n\nMultiple SMS providers: Failover and redundancy\nCAPTCHA verification: Browser-based spam prevention\nEmail verification: Additional verification method\nOAuth/OIDC: Social login as verification\nReputation systems: Trust scores for verified users\nGeographic restrictions: Limit by country/region\nTime-based rate limits: Daily/hourly limits\nPayment-based rate limit increases: Pay more = higher limits\nMulti-factor verification: Require SMS + Lightning\nVerification marketplace: Allow third-party verifiers\n\nResources\n\nRepository: github.com/pubky/homegate\nOpenAPI Spec: openapi.yaml\nPrelude Documentation: docs.prelude.so/\nPhoenixD Documentation: github.com/ACINQ/phoenixd\n\nSee Also\n\nHomeserver - Pubky homeserver documentation\nPubky Core - Core protocol and SDK\nQ37 - How users join Pubky App\nCensorship - Censorship resistance principles\n"},"Explore/Technologies/JebPubkyAIBot":{"title":"Jeb: Pubky AI Bot","links":["Explore/PubkyApp/Introduction","Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyCore/SDK","Explore/Technologies/PubkyRing"],"tags":[],"content":"Jeb is an AI-powered bot for the Pubky decentralized social network. Affectionately named ‚ÄúJeb,‚Äù this bot automatically responds to mentions with intelligent summaries, fact-checking, and other AI-powered capabilities, demonstrating how AI can enhance decentralized social experiences without compromising user sovereignty.\nOverview\nJeb operates as an autonomous agent on the Pubky network, monitoring mentions and providing helpful AI-generated responses. Unlike centralized social media bots that collect user data, Jeb operates transparently on the decentralized Pubky infrastructure, with all interactions stored on homeservers under user control.\nKey Characteristics\n\nAI-Powered: Supports multiple AI providers (Groq, OpenAI, Anthropic, OpenRouter)\nEvent-Driven: Built on Redis Streams for scalable, asynchronous processing\nProduction-Ready: Full observability with health checks, metrics, and structured logging\nPrivacy-Preserving: No data collection; all interactions occur via public Pubky protocol\nOpen Source: MIT licensed, fully transparent implementation\nHorizontally Scalable: Worker-based architecture for handling high volumes\n\nCapabilities\nSummary Generation\nJeb can summarize long threads or conversations to help users quickly understand complex discussions.\nTrigger Keywords: ‚Äúsummary‚Äù, ‚Äútl;dr‚Äù, ‚Äúrecap‚Äù, ‚Äúsummarize‚Äù\nHow It Works:\n\nUser mentions Jeb in a post with a summary request\nJeb fetches the full thread context from the homeserver\nAI generates a concise summary with key points\nResponse includes up to 3 bullet points highlighting main topics\nSafety check ensures appropriate content before posting\n\nExample Interaction:\nUser: &quot;@jeb can you summarize this thread? tl;dr&quot;\nJeb: &quot;This thread discusses X, Y, and Z. Key points:\n      ‚Ä¢ Point 1 about topic A\n      ‚Ä¢ Point 2 about topic B  \n      ‚Ä¢ Point 3 about topic C&quot;\n\nToken Management: Jeb respects configurable token budgets to avoid overwhelming AI APIs with massive threads.\nFact-Checking\nJeb can verify factual claims by searching for supporting evidence using web search APIs.\nTrigger Keywords: ‚Äúverify‚Äù, ‚Äúfact check‚Äù, ‚Äúsource?‚Äù, ‚Äúis this true?‚Äù\nHow It Works:\n\nUser mentions Jeb with a fact-check request\nJeb extracts factual claims from the content\nUses MCP (Model Context Protocol) tools to search Brave API\nAI analyzes search results and assigns verdicts per claim\nReturns overall assessment with confidence level and sources\n\nVerdict Types:\n\nAccurate: Claim supported by reliable sources\nMixed: Some accurate elements, some not\nInaccurate: Contradicted by reliable sources\nUnverifiable: Insufficient evidence to determine truth\n\nExample Interaction:\nUser: &quot;The moon landing happened in 1969. @jeb fact check&quot;\nJeb: &quot;Verdict: ACCURATE (High Confidence)\n      Claim verified by multiple reliable sources:\n      ‚Ä¢ NASA official records\n      ‚Ä¢ Independent analysis from [source]\n      ‚Ä¢ Historical documentation from [source]&quot;\n\nIntelligent Routing\nJeb uses a hybrid classification system to understand user intent:\nHeuristic Classification: Fast keyword matching for obvious cases\n\n‚Äùsummary‚Äù ‚Üí Summary action\n‚Äùfact check‚Äù ‚Üí Factcheck action\n‚Äùverify‚Äù ‚Üí Factcheck action\n\nLLM Classification: Fallback to AI when keywords are ambiguous\n\nAnalyzes full context and conversational intent\nHandles natural language requests without exact keywords\nMore flexible but slightly higher latency\n\nArchitecture\nSystem Design\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                    Pubky Network                        ‚îÇ\n‚îÇ              (Homeservers + Nexus API)                  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚îÇ\n                    ‚ñº\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚îÇ   Mention Poller     ‚îÇ ‚Üê Polls for @jeb mentions\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚îÇ\n                    ‚ñº\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚îÇ   Event Bus (Redis)  ‚îÇ ‚Üê mention.received.v1\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚îÇ\n                    ‚ñº\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚îÇ       Router         ‚îÇ ‚Üê Classifies intent\n         ‚îÇ  (Heuristics + LLM)  ‚îÇ\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚ñº                     ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Summary Workers ‚îÇ   ‚îÇ Factcheck Workers‚îÇ\n‚îÇ  (Horizontal    ‚îÇ   ‚îÇ  (Horizontal     ‚îÇ\n‚îÇ   Scaling)      ‚îÇ   ‚îÇ   Scaling)       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚îÇ                     ‚îÇ\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                    ‚ñº\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n         ‚îÇ   Reply Publisher    ‚îÇ ‚Üí Posts to Pubky\n         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nComponents\nMention Poller:\n\nQueries Pubky Nexus API for mentions\nTracks last processed mention to avoid duplicates\nEmits mention.received.v1 events to Redis Streams\nConfigurable polling interval (default: 30s)\n\nRouter:\n\nConsumes mention events from Redis Streams\nApplies heuristic keyword matching first\nFalls back to LLM classification if needed\nEmits action-specific events (e.g., action.summary.requested.v1)\nStores routing decisions for audit trail\n\nAction Workers:\n\nSummary Workers: Generate thread summaries using AI\nFactcheck Workers: Verify claims using web search + AI\nHorizontally scalable for load distribution\nEach worker type runs in its own consumer group\n\nReply Publisher:\n\nReceives completed responses from workers\nPerforms final safety checks (wordlist filtering)\nPublishes replies to Pubky via Pubky SDK\nStores published replies for auditability\n\nData Flow\n\nMention Detection: Poller finds new @jeb mentions\nEvent Emission: Mention stored in DB, event sent to Redis\nIntent Classification: Router determines user intent\nAction Processing: Workers execute appropriate logic\nResponse Generation: AI creates human-readable response\nSafety Validation: Content checked against wordlist\nPublication: Reply posted to Pubky network\n\nTechnology Stack\n\nLanguage: TypeScript/Node.js 20+\nDatabase: PostgreSQL (mention tracking, audit logs)\nEvent Bus: Redis Streams (event-driven architecture)\nAI Providers: Groq (default), OpenAI, Anthropic, OpenRouter\nWeb Search: Brave Search API (via MCP protocol)\nPubky Integration: @synonymdev/pubky SDK\nData Validation: pubky-app-specs for schema compliance\nObservability: Winston logging, Prometheus metrics, health endpoints\n\nDeployment\nQuick Start with Docker Compose\nThe fastest way to run Jeb:\n# Clone repository\ngit clone github.com/pubky/pubky-ai-bot\ncd pubky-ai-bot\n \n# Configure environment\ncp .env.example .env\n# Edit .env with your configuration (see below)\n \n# Start all services (bot, PostgreSQL, Redis)\ndocker compose up -d\n \n# Check logs\ndocker compose logs -f pubky-ai-bot\n \n# Stop services\ndocker compose down\nConfiguration\nRequired Environment Variables\n# Bot Identity (generate at iancoleman.io/bip39/)\nPUBKY_BOT_MNEMONIC=&quot;word1 word2 ... word12&quot;\n \n# AI Provider (Groq is free for development)\nAI_PRIMARY_PROVIDER=groq\nGROQ_API_KEY=gsk_your_groq_api_key\n \n# Pubky Network\nPUBKY_NETWORK=testnet  # or: mainnet (when ready)\nOptional Configuration\n# AI Models (per action)\nAI_MODEL_SUMMARY=llama-3.1-8b-instant\nAI_MODEL_FACTCHECK=llama-3.1-8b-instant\nAI_MODEL_CLASSIFIER=llama-3.1-8b-instant\n \n# Brave Search for fact-checking\nBRAVE_API_KEY=your_brave_api_key\n \n# Database (auto-configured by Docker Compose)\nDATABASE_URL=postgres://user:pass@localhost:5432/pubkybot\nREDIS_URL=redis://localhost:6379/0\n \n# Polling\nMENTION_POLL_INTERVAL_MS=30000  # 30 seconds\n \n# Performance\nWORKER_CONCURRENCY_SUMMARY=2\nWORKER_CONCURRENCY_FACTCHECK=2\nAI Provider Setup\nGroq (Free for Development)\n\nSign up at console.groq.com\nCreate an API key\nSet GROQ_API_KEY=gsk_... in .env\nUses fast Llama 3.1 models\n\nOpenAI\n\nGet API key from platform.openai.com\nSet AI_PRIMARY_PROVIDER=openai\nSet OPENAI_API_KEY=sk-...\nConfigure AI_MODEL_SUMMARY=gpt-4o-mini (or other model)\n\nAnthropic\n\nGet API key from console.anthropic.com\nSet AI_PRIMARY_PROVIDER=anthropic\nSet ANTHROPIC_API_KEY=sk-ant-...\nConfigure AI_MODEL_SUMMARY=claude-3-5-sonnet-latest\n\nOpenRouter\n\nGet API key from openrouter.ai\nSet AI_PRIMARY_PROVIDER=openrouter\nSet OPENROUTER_API_KEY=sk-or-...\nConfigure models using OpenRouter model names\n\nProduction Deployment\nHorizontal Scaling\nRun multiple worker instances for high load:\n# Single instance for poller + router (stateful polling)\nnpm start\n \n# Scale summary workers horizontally\nNODE_ENV=production WORKER_TYPE=summary npm start &amp;\nNODE_ENV=production WORKER_TYPE=summary npm start &amp;\nNODE_ENV=production WORKER_TYPE=summary npm start &amp;\n \n# Scale factcheck workers horizontally\nNODE_ENV=production WORKER_TYPE=factcheck npm start &amp;\nNODE_ENV=production WORKER_TYPE=factcheck npm start &amp;\nKubernetes Deployment\n# Poller + Router (single replica)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jeb-poller\nspec:\n  replicas: 1  # Must be 1 (stateful polling)\n  template:\n    spec:\n      containers:\n      - name: jeb-poller\n        image: pubky/jeb-bot:latest\n        env:\n        - name: NODE_ENV\n          value: production\n \n---\n \n# Summary Workers (scale as needed)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jeb-summary-workers\nspec:\n  replicas: 3  # Scale based on load\n  template:\n    spec:\n      containers:\n      - name: jeb-summary\n        image: pubky/jeb-bot:latest\n        env:\n        - name: WORKER_TYPE\n          value: summary\n \n---\n \n# Factcheck Workers (scale as needed)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jeb-factcheck-workers\nspec:\n  replicas: 3  # Scale based on load\n  template:\n    spec:\n      containers:\n      - name: jeb-factcheck\n        image: pubky/jeb-bot:latest\n        env:\n        - name: WORKER_TYPE\n          value: factcheck\nDatabase Migrations\nOn first deployment or after updates:\n# Run migrations\nnpm run db:migrate\n \n# Or via Docker\ndocker compose exec pubky-ai-bot npm run db:migrate\nObservability\nHealth Endpoints\nComprehensive Health Check:\nGET /api/health\nReturns detailed status of all services:\n\nDatabase connectivity\nRedis connectivity\nAI provider availability\nLast mention poll time\nWorker status\n\nKubernetes Readiness Probe:\nGET /api/health/ready\nReturns 200 when service is ready to accept traffic.\nKubernetes Liveness Probe:\nGET /api/health/live\nReturns 200 when service is alive (restarts if fails).\nPrometheus Metrics\nGET /metrics\nExported metrics include:\n\njeb_mentions_received_total - Total mentions processed\njeb_actions_executed_total - Actions by type and status\njeb_action_duration_seconds - Action execution time\njeb_replies_published_total - Successful replies\njeb_ai_api_calls_total - AI API usage by provider\njeb_ai_tokens_used_total - Token consumption tracking\njeb_redis_operations_total - Redis stream operations\njeb_db_query_duration_seconds - Database performance\n\nStructured Logging\nWinston-based logging with JSON output for production:\n{\n  &quot;timestamp&quot;: &quot;2025-01-05T10:30:00.000Z&quot;,\n  &quot;level&quot;: &quot;info&quot;,\n  &quot;message&quot;: &quot;Action completed&quot;,\n  &quot;mentionId&quot;: &quot;abc123&quot;,\n  &quot;actionType&quot;: &quot;summary&quot;,\n  &quot;durationMs&quot;: 1234,\n  &quot;aiProvider&quot;: &quot;groq&quot;,\n  &quot;tokensUsed&quot;: 450\n}\nLog levels: error, warn, info, debug\nSafety &amp; Moderation\nWordlist Filtering\nJeb includes configurable banned term lists to prevent inappropriate responses:\nConfiguration (config/default.json):\n{\n  &quot;safety&quot;: {\n    &quot;wordlist&quot;: {\n      &quot;enabled&quot;: true,\n      &quot;blockOnMatch&quot;: true,\n      &quot;lists&quot;: [&quot;offensive&quot;, &quot;spam&quot;, &quot;political&quot;]\n    }\n  }\n}\nBehavior:\n\nChecks generated responses before publishing\nBlocks replies containing banned terms\nLogs blocked content for audit\nCustomizable per deployment\n\nInjection Prevention\nProtection against prompt injection attacks:\n\nInput validation on all user content\nStructured prompts with clear boundaries\nRegex-based injection pattern detection\nAI content safety checks\n\nRate Limiting\nPer-user rate limiting prevents abuse:\n\nConfigurable limits per time window\nTracked in Redis for distributed rate limiting\nGraceful degradation when limits exceeded\n\nDatabase Schema\nCore Tables\nmentions: Tracks incoming mentions\n\nid - Unique mention identifier\nauthor_pubky - User who mentioned Jeb\ncontent - Mention text\npost_id - Pubky post ID\nprocessed_at - Processing timestamp\nstatus - pending, processing, completed, failed, skipped_old\n\naction_executions: Audit trail for actions\n\nid - Execution identifier\nmention_id - Reference to mention\naction_type - summary, factcheck, etc.\nstatus - pending, success, failed\nduration_ms - Execution time\ntokens_used - AI token consumption\nerror_details - Failure context (if failed)\n\nartifacts: Stores generated content\n\nid - Artifact identifier\naction_execution_id - Reference to execution\nartifact_type - summary, evidence, sources\ncontent - Generated content (JSONB)\n\nreplies: Published responses\n\nid - Reply identifier\nmention_id - Original mention\npost_id - Published Pubky post ID\ncontent - Reply text\npublished_at - Publication timestamp\n\nrouting_decisions: Classification audit\n\nid - Decision identifier\nmention_id - Mention being classified\nmethod - heuristic or llm\naction_type - Determined action\nconfidence - Classification confidence (LLM only)\nreasoning - Why this action was chosen\n\nEvent Sourcing\nAll state changes are event-driven:\n\nEvents stored in Redis Streams\nDatabase reflects event-derived state\nEnables replay and debugging\nSupports horizontal scaling\n\nAdvanced Features\nMCP Integration\nJeb uses Model Context Protocol for tool integration:\nBrave Search Tool:\n\nQueries Brave Search API for factual verification\nConfigurable result limits and timeouts\nSource credibility scoring\nAutomatic retry with exponential backoff\n\nDocker MCP Server:\n\nSeparate container for MCP tools (Dockerfile.brave-mcp)\nCommunicates with main bot via stdio protocol\nIsolated tool execution environment\n\nIdempotency\nAll operations are idempotent:\nIdempotency Keys:\n\nMention ingestion: mention:{mentionId}\nRouting decisions: route:{mentionId}\nAction executions: action:{actionType}:{mentionId}\n\nTTL: 24 hours (prevents duplicate processing)\nBenefits:\n\nSafe to retry failed operations\nPrevents duplicate replies\nHandles network failures gracefully\n\nDead Letter Queue\nFailed messages moved to DLQ for investigation:\n# Check DLQ length\nredis-cli xlen pubky:dlq\n \n# Read failed messages\nredis-cli xread STREAMS pubky:dlq 0\n \n# Reprocess from DLQ\nnpm run reprocess -- --from-dlq\nReprocessing\nManually reprocess mentions:\n# Reprocess specific mention\nnpm run reprocess -- --mention-id abc123\n \n# Reprocess recent failures\nnpm run reprocess:recent\n \n# Reprocess with limits\nnpm run reprocess:limited -- --limit 10\nDevelopment\nLocal Development Setup\n# Install dependencies\nnpm ci\n \n# Start PostgreSQL and Redis (via Docker Compose)\ndocker compose up -d postgres redis\n \n# Run migrations\nnpm run db:migrate\n \n# Start development server with hot reload\nnpm run dev\nTesting\n# Run all tests\nnpm test\n \n# Run tests with coverage\nnpm test:coverage\n \n# Run tests in watch mode\nnpm test:watch\n \n# Run tests in Docker (includes DB and Redis)\nnpm run test:docker\nTest categories:\n\nUnit tests: Individual service logic\nIntegration tests: Database operations\nE2E tests: Full workflow simulations\n\nCode Quality\n# Lint TypeScript\nnpm run lint\nnpm run lint:fix\n \n# Format code\nnpm run format\n \n# Type check\nnpm run typecheck\nUse Cases\nCommunity Moderation\nUse Jeb to help moderators:\n\nSummarize long complaint threads\nFact-check claims in disputes\nProvide context for moderation decisions\n\nNews Verification\nCombat misinformation:\n\nFact-check breaking news claims\nProvide source citations\nAssess claim credibility\n\nThread Digests\nHelp users catch up:\n\nSummarize active discussions\nExtract key points from long threads\nHighlight consensus or disagreements\n\nEducational Support\nAssist learning:\n\nVerify historical or scientific claims\nProvide sources for further reading\nSummarize complex explanations\n\nResearch Assistance\nAid researchers:\n\nQuick literature verification\nSource finding\nClaim cross-referencing\n\nLimitations &amp; Considerations\nAI Model Limitations\n\nHallucinations: AI may generate plausible but incorrect information\nBias: Models reflect training data biases\nContext Window: Limited thread history can be processed\nCost: AI API calls incur costs at scale\n\nNetwork Dependencies\n\nHomeserver Availability: Relies on homeserver uptime\nNexus API: Depends on Pubky Nexus for mention polling\nWeb Search: Fact-checking requires Brave API access\nRedis/PostgreSQL: Infrastructure dependencies\n\nFactchecking Constraints\n\nSource Quality: Limited by search engine results\nReal-time Events: May not have recent information\nSubjective Topics: Works best for objective facts\nLanguage: Primarily English (model-dependent)\n\nPrivacy Considerations\n\nPublic Interactions: All mentions and replies are public\nAI Provider: Content sent to third-party AI APIs\nSearch Queries: Fact-check queries sent to Brave\nAudit Logs: All interactions logged for debugging\n\nOperational Considerations\n\nPolling Latency: 30s default delay before responding\nAI Rate Limits: Provider-specific throughput limits\nToken Budgets: Large threads may be truncated\nSafety Trade-offs: Wordlist may block legitimate content\n\nFuture Enhancements\nPotential improvements for Jeb:\n\nMulti-language Support: Automatic translation and localization\nImage Analysis: OCR and image fact-checking\nSentiment Analysis: Detect and respond to emotional tone\nThread Visualization: Generate visual summaries (graphs, timelines)\nCollaborative Filtering: User feedback on response quality\nCustom Actions: Plugin system for extensible capabilities\nReal-time Streaming: WebSocket-based instant responses\nFine-tuned Models: Domain-specific model training\nFederated Learning: Privacy-preserving model improvement\nVoice Responses: Audio summary generation\n\nResources\n\nRepository: github.com/pubky/pubky-ai-bot\nDocker Images: Docker Hub (if published)\nConfiguration Examples: config/\nMigration Files: src/infrastructure/database/migrations/\n\nAI Providers\n\nGroq: console.groq.com\nOpenAI: platform.openai.com\nAnthropic: console.anthropic.com\nOpenRouter: openrouter.ai\n\nRelated Tools\n\nBIP39 Mnemonic Generator: iancoleman.io/bip39/\nBrave Search API: brave.com/search/api/\nModel Context Protocol: modelcontextprotocol.io\n\nSee Also\n\nPubky App - Social network where Jeb operates\nPubky Nexus - Backend API for mention polling\nPubky SDK - SDK used for posting replies\nHomeserver - Where Jeb‚Äôs posts are stored\nPubky Ring - Identity management (for bot account)\n"},"Explore/Technologies/KeyPair":{"title":"Key Pair","links":[],"tags":[],"content":"Cryptographic Key Pairs\nA cryptography key pair consists of two related but distinct cryptographic keys:\n\nPrivate Key: A secret key that is used to decrypt, sign, or authenticate data. It‚Äôs called ‚Äúprivate‚Äù because it should be kept confidential and secure to prevent unauthorized access.\nPublic Key: A publicly accessible key that is used to encrypt, verify, or authenticate data. It‚Äôs called ‚Äúpublic‚Äù because it can be shared freely without compromising the security of the system.\n\nHow do key pairs work?\nHere‚Äôs a simplified overview of how key pairs are used in various cryptographic scenarios:\nEncryption\n\nAlice wants to send a secure message to Bob.\nBob generates a key pair and shares his public key with Alice.\nAlice uses Bob‚Äôs public key to encrypt the message.\nBob uses his private key to decrypt the message.\n\nDigital Signatures\n\nAlice wants to send a document to Bob and prove its authenticity.\nAlice generates a key pair and uses her private key to sign the document.\nBob uses Alice‚Äôs public key to verify the signature and ensure the document hasn‚Äôt been tampered with.\n\nAuthentication\n\nAlice wants to access a secure system or service.\nThe system generates a key pair and shares its public key with Alice.\nAlice uses the system‚Äôs public key to encrypt a challenge or password.\nThe system uses its private key to decrypt the challenge or password and authenticate Alice.\n\nKey Pair Properties\n\nAsymmetric: Key pairs are asymmetric, meaning that the private key is not easily derived from the public key.\nMathematical relationship: The private and public keys are mathematically related, allowing for encryption, decryption, signing, and verification.\nUnique: Each key pair is unique, ensuring that data encrypted with a public key can only be decrypted with the corresponding private key.\n\nTypes of Key Pairs\n\nRSA (Rivest-Shamir-Adleman): A popular algorithm used for encryption, decryption, and digital signatures.\nElliptic Curve Cryptography (ECC): A more modern algorithm used for encryption, decryption, and digital signatures, offering better security with smaller key sizes.\nDiffie-Hellman (DH): A key exchange algorithm used to establish a shared secret key between two parties.\n\nIn summary, cryptography key pairs are a fundamental component of secure online communications, enabling encryption, digital signatures, and authentication. By using a pair of related but distinct keys, key pairs provide a secure way to protect data and ensure its authenticity."},"Explore/Technologies/MainlineDHT":{"title":"Mainline DHT","links":["Explore/Technologies/DHT","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Concepts/Censorship","Explore/Technologies/PKDNS"],"tags":[],"content":"Mainline DHT is a standard Distributed Hash Table (DHT) implementation widely used in the BitTorrent network, based on the Kademlia protocol. This decentralized system allows for efficient data storage and retrieval across a vast network of nodes, making it highly resilient and scalable.\nPubky uses Mainline DHT as the foundation for PKARR (Public Key Addressable Resource Records), enabling decentralized identity and discovery without central authorities.\nKey Features\n\nDecentralization: It operates without a central authority, enhancing its resilience against failures and censorship.\nScalability: It can easily scale to accommodate more data and users by adding more nodes to the network.\nEfficiency: By distributing data across multiple nodes, Mainline DHT provides fast access to data without the need for a central server.\nProven Track Record: 15+ years of production use in the BitTorrent network with an estimated 10 million nodes worldwide\nEphemeral Storage: Records stored via BEP44 are temporary and require periodic republishing\nSecurity Extensions: Implements BEP42 security measures and Sybil attack resistance\n\nHow Pubky Uses Mainline DHT\nIdentity Resolution\nWhen you access a public key domain (e.g., pubky://o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy):\n\nPKDNS queries Mainline DHT for that public key\nDHT returns signed PKARR records\nRecords contain homeserver URLs and other DNS-style resource records\nYour client can now connect to the user‚Äôs homeserver\n\nData Lifecycle\n\nPublishing: Users sign DNS packets and publish to DHT (directly or via relay)\nCaching: Clients and relays cache records extensively to minimize DHT traffic\nRepublishing: Records expire after a few hours and must be republished by users, friends, or service providers\nDiscovery: Popular records may be kept alive by DNS servers as they receive queries\n\nTechnical Implementation\nPubky‚Äôs Mainline DHT client is implemented in Rust with:\n\nClient Mode: Query and store values without accepting incoming requests\nServer Mode: Act as a routing/storing node, contributing to network capacity\nAdaptive Mode: Start as client, upgrade to server after 15 minutes if publicly accessible\n\nSupported BEPs (BitTorrent Enhancement Proposals)\n\nBEP 5: Core DHT Protocol\nBEP 42: DHT Security Extension\nBEP 43: Read-only DHT Nodes\nBEP 44: Storing Arbitrary Data in the DHT\n\nApplications\n\nBitTorrent Network: Mainline DHT adds tracker capabilities to each peer in the BitTorrent network, enhancing its resilience and reducing dependency on centralized trackers.\nPubky Identity System: Enables self-sovereign public key domains without DNS registrars\nPKDNS: DNS resolution for public key domains via DHT lookups\nPeer-to-Peer File Sharing: Beyond BitTorrent, DHTs like Mainline are used for instant messaging, name resolution, and other peer-to-peer applications.\n\nWhy Mainline DHT?\nFrom the PKARR project‚Äôs perspective, Mainline DHT was chosen because:\n\nProven at Scale: Largest DHT in existence with ~10 million nodes\nBattle-Tested: 15 years facilitating trackerless torrents worldwide\nGenerous Retention: Mutable data retention reduces republishing frequency\nWide Support: Implementations in most languages, well-understood by experts\nNo Bootstrap Required: Leverage existing infrastructure instead of building new networks\n\nSecurity Considerations\n\nNot a Storage Platform: Records are ephemeral and will be dropped without regular republishing\nNot Realtime: Records are heavily cached; updates may take time to propagate\nSybil Resistance: Implementation includes measures against Vertical Sybil Attacks\nRate Limiting: Server operators should implement custom rate limiting for DoS protection\n\nLinks\n\nImplementation: github.com/pubky/mainline - Rust DHT client/server\nAPI Documentation: docs.rs/mainline\nExamples: github.com/pubky/mainline/tree/main/examples\nWikipedia: Mainline DHT\nKademlia Protocol: Wikipedia\n\nRelated Documentation\n\nPKARR - Public Key Addressable Resource Records built on Mainline DHT\nPKDNS - DNS server that resolves public key domains via DHT queries\nDHT - General Distributed Hash Table concepts\n"},"Explore/Technologies/PKDNS":{"title":"PKDNS","links":["Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/Technologies/DNS","Explore/Technologies/DoH","Explore/PubkyCore/Introduction"],"tags":[],"content":"PKDNS: Public Key DNS Server\nPKDNS is a DNS server that enables self-sovereign and censorship-resistant domain names by resolving PKARR (Public Key Addressable Resource Records) hosted on the Mainline DHT. It bridges the gap between traditional DNS infrastructure and public key-based domains, allowing anyone to access the decentralized web using standard DNS protocols.\nOverview\nPKDNS makes public key domains accessible to everyone by acting as a DNS resolver that understands both traditional ICANN domains and PKARR-based public key domains. When you query a public key domain (52-character base32 encoded public key), PKDNS fetches the signed DNS records from the Mainline DHT, verifies the signature, and returns them to your browser or application‚Äîjust like traditional DNS.\nKey Innovation\nInstead of relying on ICANN registrars and centralized name servers, PKDNS enables:\n\nSelf-sovereign domains: Your Ed25519 public key IS your domain\nCensorship resistance: Records are distributed across ~10 million DHT nodes\nNo registration fees: Publish records directly to the DHT\nCryptographic verification: All records are signed and verifiable\nICANN fallback: Still resolves traditional domains seamlessly\n\nHow It Works\nResolution Flow\n\nUser queries domain: Browser or app requests 7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy\nPKDNS recognizes format: Identifies 52-character base32 as a public key domain\nDHT lookup: Queries the Mainline DHT for PKARR records associated with that public key\nSignature verification: Validates that records were signed by the private key holder\nCache and return: Caches the verified records and returns DNS response to client\nICANN fallback: For traditional domains like example.com, forwards to upstream DNS (default: 8.8.8.8)\n\nPublic Key Domain Format\nPublic key domains use base32-encoded Ed25519 public keys:\n\nLength: 52 characters (z-base-32 encoding)\nExample: 7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy\nSubdomains: Support standard subdomain syntax (e.g., blog.7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy)\n\nSupported Record Types\nPKDNS currently supports the most common DNS record types:\n\nA: IPv4 addresses\nAAAA: IPv6 addresses\nTXT: Text records\nCNAME: Canonical name records\nMX: Mail exchange records\n\nFor other record types, use bind9 or similar full-featured DNS servers.\nFeatures\nDNS-over-HTTPS (DoH)\nPKDNS supports DNS-over-HTTPS, enabling encrypted DNS queries from browsers:\n\nConfigure browser to use a PKDNS DoH endpoint\nAll DNS queries encrypted over HTTPS\nPrevents ISP snooping on DNS traffic\nPublic DoH endpoints available in servers.txt\n\nCaching\nMulti-layer caching for optimal performance:\n\nResponse cache: Caches DNS responses to reduce DHT queries\nPKARR cache: Stores verified PKARR records from DHT\nConfigurable TTL: Respects DNS TTL values from records\n\nRate Limiting\nBuilt-in protection against abuse:\n\nPer-IP rate limiting to prevent DoS attacks\nConfigurable thresholds and timeouts\nProtects both the server and the DHT network\n\nDynamic DNS (DynDNS)\nSupport for dynamic IP updates:\n\nCLI tool for publishing updated A/AAAA records\nAutomated IP detection from multiple providers\nPeriodic republishing to keep records alive on DHT\nPerfect for home servers and dynamic IP addresses\n\nHybrid Resolution\nSeamlessly resolves both public key domains and traditional domains:\n\nPublic key domains (52 chars) ‚Üí DHT lookup\nICANN domains ‚Üí Upstream DNS fallback\nConfigurable upstream DNS server\nNo special client configuration needed\n\nGetting Started\nUsing Public Hosted Servers\nThe easiest way to try PKDNS:\n\n\nChoose a public server: Check servers.txt for available DNS-over-HTTPS endpoints\n\n\nConfigure your browser:\n\nFirefox: Settings ‚Üí Network Settings ‚Üí Enable DNS over HTTPS ‚Üí Custom ‚Üí Enter DoH URL\nChrome: Settings ‚Üí Privacy and security ‚Üí Security ‚Üí Use secure DNS ‚Üí Custom ‚Üí Enter DoH URL\nEdge: Settings ‚Üí Privacy, search, and services ‚Üí Security ‚Üí Use secure DNS ‚Üí Choose provider\n\n\n\nTest it works: Visit http://7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy/\n\n\nSelf-Hosting PKDNS\nPre-Built Binaries\n# Download latest release for your platform\nwget github.com/pubky/pkdns/releases/latest/download/pkdns-linux-x64.tar.gz\n \n# Extract\ntar -xzf pkdns-linux-x64.tar.gz\n \n# Run (requires port 53 access)\nsudo ./pkdns --verbose\nBuild from Source\n# Install Rust toolchain\ncurl --proto &#039;=https&#039; --tlsv1.2 -sSf sh.rustup.rs | sh\n \n# Clone and build\ngit clone github.com/pubky/pkdns.git\ncd pkdns\ncargo build --release\n \n# Run\nsudo ./target/release/pkdns --verbose\nDocker Deployment\n# Using Docker Compose\ngit clone github.com/pubky/pkdns.git\ncd pkdns\ndocker compose up -d\n \n# Or pull directly\ndocker pull synonymsoft/pkdns\ndocker run -p 53:53/udp -p 53:53/tcp synonymsoft/pkdns\nConfiguration\nCommand-Line Options\npkdns [OPTIONS]\n \nOptions:\n  -f, --forward &lt;FORWARD&gt;      # ICANN fallback DNS server [default: 8.8.8.8:53]\n  -v, --verbose                # Show verbose output [default: false]\n  -c, --config &lt;CONFIG&gt;        # Path to config file\n  -p, --pkdns-dir &lt;PKDNS_DIR&gt;  # Base directory for data [default: ~/.pkdns]\n  -h, --help                   # Print help\n  -V, --version                # Print version\nConfiguration File\nLocation: ~/.pkdns/pkdns.toml\nExample configuration:\n# Upstream DNS for ICANN domains\nfallback_dns = &quot;8.8.8.8:53&quot;\n \n# Enable DNS-over-HTTPS\n[doh]\nenabled = true\nport = 443\ncert_path = &quot;/path/to/cert.pem&quot;\nkey_path = &quot;/path/to/key.pem&quot;\n \n# Rate limiting\n[rate_limit]\nrequests_per_minute = 100\nburst_size = 20\n \n# Caching\n[cache]\nmax_entries = 10000\nttl_seconds = 300\nSee sample-config.toml for full options.\nVerification\nTest that PKDNS is working correctly:\nVerify Public Key Domain Resolution\n# Replace SERVER_IP with your PKDNS server IP (127.0.0.1 for local)\nnslookup 7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy SERVER_IP\nExpected output: IP address(es) for the public key domain\nVerify ICANN Domain Fallback\nnslookup example.com SERVER_IP\nExpected output: Standard DNS response for example.com\nBrowser Test\nNavigate to: http://7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy/\nExpected: Website loads successfully\n\nTip: Always add ./ at the end of public key domain URLs, otherwise browsers may search instead of resolve.\n\nPublishing Your Own Public Key Domain\nTo publish a website on a public key domain:\nGenerate Key Pair\n# Using pkdns CLI\npkdns-cli generate\n \n# Outputs:\n# Public key: 7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy\n# Private key (seed): &lt;52-character secret&gt;\n‚ö†Ô∏è Security: Store your private key securely. Anyone with the private key can publish records for your domain.\nCreate DNS Zone File\nCreate a standard DNS zone file with your records:\n@ 3600 IN A 203.0.113.42\n@ 3600 IN AAAA 2001:db8::1\nwww 3600 IN CNAME @\nPublish to DHT\n# Using pkdns CLI\npkdns-cli publish --seed &lt;your-private-key&gt; --zone-file records.zone\n \n# Or with dynamic IP detection\npkdns-cli publish --seed &lt;your-private-key&gt; --zone-file records.zone --detect-ip\nKeep Records Alive\nDHT records expire after a few hours. For persistent domains:\n# Manual republishing\nwhile true; do\n  pkdns-cli publish --seed &lt;your-private-key&gt; --zone-file records.zone\n  sleep 3600  # Republish every hour\ndone\n \n# Or use DynDNS features for automation\nSee the publishing guide for detailed instructions.\nUse Cases\nSelf-Sovereign Web Publishing\nPublish websites without:\n\nDomain registrars (no annual fees)\nDNS hosting services (no third-party control)\nRenewal requirements (keys don‚Äôt expire)\nCensorship risk (distributed across DHT)\n\nDecentralized Applications\nEnable dApps to use human-readable addresses:\n\nNo smart contract required for DNS\nCryptographic verification built-in\nWorks with existing web infrastructure\nLow latency (~100ms typical resolution)\n\nDevelopment &amp; Testing\nInstant domain names for development:\n\nGenerate test domains in seconds\nNo registration or setup fees\nUpdate records instantly\nPerfect for CI/CD pipelines\n\nPrivacy-Focused Browsing\nAccess censorship-resistant content:\n\nRecords can‚Äôt be seized or altered\nNo central authority to pressure\nWorks through standard DNS protocols\nCompatible with existing privacy tools\n\nPersonal Identity\nUse your public key as your digital identity:\n\nSingle domain across all services\nProvable ownership via signatures\nNo platform lock-in\nPortable across applications\n\nArchitecture\nComponents\nServer (pkdns): Main DNS server process\n\nListens on port 53 (UDP/TCP) for DNS queries\nOptional DNS-over-HTTPS endpoint (port 443)\nMulti-threaded request handling\nIntegration with Mainline DHT client\n\nCLI Tool (pkdns-cli): Command-line utilities\n\nKey generation and management\nRecord publishing and updates\nZone file parsing\nDynamic IP detection\n\nPKARR Resolver: Core resolution logic\n\nDHT query coordination\nSignature verification\nRecord caching and TTL management\nBootstrap node management\n\nResponse Cache: Query optimization\n\nIn-memory cache of DNS responses\nConfigurable size and TTL\nLRU eviction policy\n\nPerformance Characteristics\n\nResolution time: ~100-300ms for cold cache (DHT lookup)\nCached resolution: &lt;1ms (memory lookup)\nThroughput: Thousands of queries per second (cached)\nMemory footprint: ~50MB base + cache size\nDHT network: ~10 million nodes, high availability\n\nSecurity Model\n\nCryptographic verification: All PKARR records are Ed25519-signed\nNo trust required: Clients verify signatures independently\nCensorship resistance: Distributed storage across massive DHT\nDoS protection: Rate limiting and query validation\nPrivacy: DoH encryption for DNS queries\n\nLimitations &amp; Considerations\nPort 53 Requirement\nDNS servers traditionally require port 53, which needs root/admin privileges:\n\nLinux: Use sudo or configure capabilities\nmacOS: System services may occupy port 53 (Docker Desktop)\nWindows: May conflict with other DNS services\nWorkaround: Use DNS-over-HTTPS only (doesn‚Äôt require port 53)\n\nDHT Ephemeral Storage\nRecords expire after a few hours and must be republished:\n\nActive domains: Need periodic republishing (~hourly)\nAutomated solutions: DynDNS features handle this\nTrade-off: Prevents DHT pollution but requires maintenance\n\nRecord Size Limit\nPKARR packets must be ‚â§1000 bytes:\n\nLimits number of records per domain\nUse CNAME indirection for complex setups\nConsider multiple public keys if needed\n\nLimited Record Type Support\nCurrently supports only: A, AAAA, TXT, CNAME, MX\n\nUse bind9 for advanced record types (SRV, CAA, etc.)\nMay expand in future versions\n\nBrowser Trailing Slash\nBrowsers may search instead of resolve domains:\n\nAlways append ./ to public key domains in URL bar\nExample: http://7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy./\nNot needed for bookmarks or links\n\nTroubleshooting\n‚ÄùAddress already in use‚Äù Error\nProblem: Port 53 is occupied by another service\nSolutions:\n\nDocker Desktop (macOS): Disable DNS proxy in Docker settings\nsystemd-resolved (Ubuntu): Disable or reconfigure\nAlternative: Run only DoH server (doesn‚Äôt need port 53)\n\nPKDNS Domains Don‚Äôt Resolve\nCheck:\n\nServer running: ps aux | grep pkdns\nPort accessible: nc -zvu 127.0.0.1 53\nDHT connectivity: Check verbose logs for bootstrap\nFirewall rules: Allow UDP/TCP port 53\n\nICANN Domains Don‚Äôt Resolve\nProblem: Upstream DNS not configured correctly\nSolution:\n# Use reliable upstream DNS\npkdns -f 8.8.8.8:53  # Google DNS\npkdns -f 1.1.1.1:53  # Cloudflare DNS\nSlow Resolution Times\nCauses:\n\nCold cache (first query to DHT is slower)\nDHT connectivity issues\nNetwork latency\n\nSolutions:\n\nPre-warm cache for frequently accessed domains\nIncrease cache size in config\nCheck network connectivity to DHT bootstrap nodes\n\nResources\n\nRepository: github.com/pubky/pkdns\nReleases: github.com/pubky/pkdns/releases\nDocker Image: hub.docker.com/r/synonymsoft/pkdns\nPublic Servers: servers.txt\nZone Explorer: pkdns.net\nTelegram Chat: t.me/pubkycore\n\nDocumentation\n\nDNS-over-HTTPS Setup\nDynamic DNS Configuration\nLogging Configuration\nPublishing Guide\n\nBlog Posts\n\nMainline DHT Censorship Explained\nPublic Key Domains Censorship Resistance Explained\n\nRelated Tools\n\npkarr: Core PKARR library and specification\npkdns-digger: Web-based DNS record lookup tool for PKARR/PKDNS\npkdns-vanity: Generate vanity public key domains\nawesome-pubky: Curated list of Pubky resources\n\nSee Also\n\nPKARR - Public Key Addressable Resource Records\nMainline DHT - Distributed hash table powering PKDNS\nDNS - Traditional Domain Name System\nDoH - DNS over HTTPS protocol\nPubky Core - Core protocol and infrastructure\n"},"Explore/Technologies/Paykit":{"title":"Paykit","links":["Explore/PubkyCore/Homeserver","Explore/Technologies/PubkyNoise","Explore/Technologies/PubkyRing","Explore/Concepts/SemanticSocialGraph"],"tags":[],"content":"Paykit: Decentralized Payment Protocol (Work in Progress)\n\n‚ö†Ô∏è NOTE: Paykit is currently under active development and is NOT production-ready. The protocol and implementation are subject to significant changes. Integration work in Bitkit serves as a testbed for protocol development.\n\nOverview\nPaykit is a payment protocol (work in progress) built on Pubky that aims to enable payment discovery, negotiation, and coordination across multiple payment methods (Bitcoin onchain, Lightning Network, and potentially others).\nCore Concept\nPaykit abstracts payment complexity behind a single, static Pubky public key. Your public key becomes a universal payment identifier - recipients would discover your available payment methods by querying your homeserver‚Äôs public directory at /pub/paykit.app/v0/.\nThis enables applications where users pay directly to profiles, offering an intuitive experience when multiple payment methods are possible.\nProposed Architecture (Under Development)\nThree-Layer System\n\n\nPublic Directory Layer (paykit-lib)\n\nPublish payment methods to Pubky homeservers\nDiscover methods from other users‚Äô public keys\nPublic read access for discovery\n\n\n\nInteractive Payment Layer (paykit-interactive)\n\nEncrypted channels using Pubky Noise for private negotiation\nReceipt exchange and payment coordination\nEnd-to-end encrypted communication\n\n\n\nSubscription &amp; Automation Layer (paykit-subscriptions)\n\nRecurring payment agreements with cryptographic signatures\nAuto-pay rules with spending limits\nPayment request system with expiration\n\n\n\nKey Features (In Development)\nPayment Method Discovery\nQuery any Pubky identity to discover their available payment methods (onchain, Lightning, or custom).\nEncrypted Payment Negotiation\nPrivate channels for payment coordination using Pubky Noise, a Noise Protocol (IK pattern) implementation built for the Pubky ecosystem. This avoids revealing payment details publicly.\nPubky Noise provides:\n\nEnd-to-end encrypted communication channels\nThree-step IK handshake for secure connections\nWebSocket and TCP transport support\nIntegration with Pubky identity system\n\nSubscriptions &amp; Recurring Payments\n\nCryptographically signed subscription agreements\nFlexible billing frequencies (daily, weekly, monthly, yearly)\nAuto-pay with configurable spending limits\nReplay protection via nonce tracking\n\nSecurity Model (Evolving)\nSealed Blob v1 Encryption: Sensitive data on public Pubky paths is encrypted:\n\nPayment requests encrypted to recipient‚Äôs Noise public key\nSubscription proposals/agreements encrypted per-party\nX25519 ECDH + HKDF-SHA256 + ChaCha20-Poly1305\nPrerequisite: Noise endpoint published at /pub/paykit.app/v0/noise\n\nSee Pubky Noise for details on the encrypted channel implementation.\nCurrent Implementation Status\nCurrent Version: 1.0.1 (Work in Progress)\n\nüöß Core library under development\nüöß Interactive protocol (WIP)\nüöß Subscription system (WIP)\nüöß Security model evolving\nüöß Protocol specification in flux\nüöß Integration testing in Bitkit (iOS/Android)\n\nDemo Applications\n\nCLI: Command-line reference implementation (WIP)\nWeb: WebAssembly browser demo\niOS Demo: SwiftUI prototype with Keychain storage\nAndroid Demo: Jetpack Compose prototype\n\nTesting Integrations\n\nBitkit iOS: Protocol testing integration (~80 files)\nBitkit Android: Protocol testing integration (~97 files)\nPubky Ring: Identity and key management integration\n\nPotential Use Cases (Future)\nDirect Peer Payments\nPay directly to profiles using Pubky identity without requesting addresses or invoices.\nContent Monetization\n\nPaywalls for content\nTip jars for creators\nMicropayments for API access\n\nSubscription Services\n\nMagazine subscriptions\nSaaS billing\nRecurring donations\n\nE-Commerce\n\nOnline store checkouts\nMarketplace payments\nService bookings\n\nTechnical Details (Subject to Change)\nStorage Paths\n\nPayment methods: /pub/paykit.app/v0/{methodId} (public)\nNoise endpoint: /pub/paykit.app/v0/noise (public)\nPayment requests: /pub/paykit.app/v0/requests/{id} (encrypted)\nSubscriptions: /pub/paykit.app/v0/subscriptions/* (encrypted)\n\nSupported Payment Methods (Planned)\n\nonchain: Bitcoin on-chain addresses\nlightning: BOLT11 invoices, LNURL-pay, Lightning addresses\nCustom: Extensible to other methods (under consideration)\n\nKey Management\n\nEd25519: Identity signing and verification\nX25519: Noise Protocol key exchange\nDerived from same seed via HKDF (Pubky Ring integration)\n\nRelationship to Pubky Core\nPaykit is designed as a layer 2 protocol on top of Pubky Core:\n\nUses Pubky homeservers for storage\nLeverages Pubky‚Äôs public key identity system\nIntegrates with Pubky‚Äôs DHT-based discovery\nExtends Pubky with payment-specific functionality\n\nDevelopment Status &amp; Roadmap\n\n‚è≥ Protocol specification stabilization\n‚è≥ Security audit and hardening\n‚è≥ Cross-platform testing and validation\n‚è≥ Production deployment planning\n‚è≥ Interoperability testing\n‚è≥ Performance optimization\n\nRelated Research\nAtomicity Protocol - Peer-to-peer mutual credit system research exploring trust-based payment routing using Pubky‚Äôs Semantic Social Graph. Designed as settlement infrastructure for credit issuance and transfer across economic scales from peer-to-peer to institutional banking. Currently in research phase.\nResources\n\nRepository (WIP Fork): github.com/BitcoinErrorLog/paykit-rs\nDocumentation: paykit-rs/docs/ (In development)\nProtocol Spec: PAYKIT_PROTOCOL_V0.md (Draft)\nBitkit iOS (WIP Testing): github.com/BitcoinErrorLog/bitkit-ios\nBitkit Android (WIP Testing): github.com/BitcoinErrorLog/bitkit-android\nPubky Ring (Identity Manager): See dedicated page for identity and key management\n\n\n‚ö†Ô∏è Important: Do not use Paykit for production applications. The protocol is a work in progress and subject to breaking changes."},"Explore/Technologies/PubkyCLI":{"title":"Pubky CLI","links":["Explore/PubkyCore/SDK","Explore/PubkyCore/Homeserver","Explore/Technologies/PubkyDocker","Explore/PubkyCore/API"],"tags":[],"content":"Pubky CLI is a command-line tool for interacting with Pubky homeservers. Built in Rust, it provides both user-facing and administrative capabilities for managing homeservers, testing deployments, and automating workflows.\nOverview\nPubky CLI wraps the official Pubky SDK and provides:\n\nUser Operations: Signup, signin, data management, session handling\nAdmin Operations: User management, server stats, invite token generation\nTesting Tools: Integration with pubky-testnet for local development\nAutomation: Script-friendly interface for CI/CD and deployment automation\n\nInstallation\nFrom Crates.io\ncargo install pubky-cli\nFrom Source\ngit clone github.com/pubky/pubky-cli\ncd pubky-cli\ncargo install --path .\nVerify Installation\npubky-cli --version\nQuick Start\nCreate Recovery File\nRecovery files store encrypted identity keys:\n# Generate recovery file with passphrase\npubky-cli tools generate-recovery ./alice.recovery --passphrase mypass\n \n# Prints the public key\n# Example: z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty\nUser Signup\n# Sign up with homeserver (testnet)\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user signup &lt;homeserver-pubkey&gt; ./alice.recovery --testnet\n \n# With signup code (for gated servers)\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user signup --signup-code &lt;code&gt; &lt;homeserver-pubkey&gt; ./alice.recovery --testnet\nAdmin Operations\n# Get server info\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin info\n \n# Generate signup token\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin generate-token\nUser Commands\nAuthentication\n# Sign in\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user signin ./alice.recovery --testnet\n \n# Check session\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user session ./alice.recovery --testnet\n \n# Sign out\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user signout ./alice.recovery --testnet\nData Management\n# Publish data from file\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user publish &quot;/pub/myapp/data.json&quot; ./local-file.json ./alice.recovery --testnet\n \n# Get data by path\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user get &quot;/pub/myapp/data.json&quot; ./alice.recovery --testnet\n \n# List directory\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user list &quot;/pub/myapp/&quot; ./alice.recovery --testnet\n \n# Delete data\nPUBKY_CLI_RECOVERY_PASSPHRASE=mypass \\\n  pubky-cli user delete &quot;/pub/myapp/data.json&quot; ./alice.recovery --testnet\nAdmin Commands\nUser Management\n# Disable user\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin user disable &lt;user-pubkey&gt;\n \n# Enable user\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin user enable &lt;user-pubkey&gt;\n \n# Delete user data\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin user delete &lt;user-pubkey&gt; /path/to/file\nServer Operations\n# Get server statistics\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin info\n \n# Generate invite/signup token\nPUBKY_ADMIN_PASSWORD=admin \\\n  pubky-cli admin generate-token\nEnvironment Variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariablePurposeExamplePUBKY_ADMIN_PASSWORDAdmin API passwordadminPUBKY_CLI_RECOVERY_PASSPHRASEAuto-decrypt recovery filesmypassphrasePUBKY_PKARR_BOOTSTRAPOverride PKARR bootstrap nodesnode1.example.com:6881,node2.example.com:6881PUBKY_PKARR_RELAYSCustom PKARR relay URLsrelay1.example.com,relay2.example.comPUBKY_PKARR_TIMEOUT_MSPKARR request timeout5000\nShell Completions\nGenerate tab completion scripts for your shell:\n# Bash\npubky-cli tools completions bash --outfile &quot;$(brew --prefix)/etc/bash_completion.d/pubky-cli&quot;\n \n# Zsh\nmkdir -p ~/.zfunc\npubky-cli tools completions zsh --outfile ~/.zfunc/_pubky-cli\necho &#039;fpath+=(&quot;$HOME/.zfunc&quot;)&#039; &gt;&gt; ~/.zshrc\n \n# Fish\npubky-cli tools completions fish --outfile ~/.config/fish/completions/pubky-cli.fish\n \n# PowerShell\npubky-cli tools completions powershell --outfile $PROFILE/../Completions/pubky-cli.ps1\nSupported shells: bash, zsh, fish, powershell, elvish\nTesting &amp; CI\nLocal Testing\n# Run all tests (includes integration tests)\ncargo test\n \n# Test uses pubky-testnet internally - no external setup needed\nExample Workflow\n#!/bin/bash\n# Automated user onboarding script\n \n# 1. Generate recovery file\npubky-cli tools generate-recovery ./user.recovery --passphrase $PASSWORD\n \n# 2. Sign up\nPUBKY_CLI_RECOVERY_PASSPHRASE=$PASSWORD \\\n  pubky-cli user signup $HOMESERVER_PK ./user.recovery --testnet\n \n# 3. Sign in\nPUBKY_CLI_RECOVERY_PASSPHRASE=$PASSWORD \\\n  pubky-cli user signin ./user.recovery --testnet\n \n# 4. Publish initial profile\nPUBKY_CLI_RECOVERY_PASSPHRASE=$PASSWORD \\\n  pubky-cli user publish &quot;/pub/pubky.app/profile.json&quot; ./profile.json ./user.recovery --testnet\n \necho &quot;User onboarded successfully!&quot;\nUse Cases\nLocal Development\nTest homeserver functionality without building custom clients:\n# Start local homeserver\ncargo run -p pubky-homeserver -- --data-dir ~/.pubky\n \n# Test with CLI\npubky-cli admin info\nDeployment Automation\nScript homeserver configuration and user provisioning:\n# Generate batch signup tokens\nfor i in {1..100}; do\n  PUBKY_ADMIN_PASSWORD=$ADMIN_PASS pubky-cli admin generate-token &gt;&gt; tokens.txt\ndone\nIntegration Testing\nValidate end-to-end flows in CI:\n# CI test script\ncargo test --all\nHomeserver Administration\nManage users and monitor server health:\n# Disable abusive user\nPUBKY_ADMIN_PASSWORD=admin pubky-cli admin user disable $ABUSER_KEY\n \n# Check server stats\nPUBKY_ADMIN_PASSWORD=admin pubky-cli admin info\nArchitecture\nProject Structure\npubky-cli/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ admin.rs      # Admin API wrapper\n‚îÇ   ‚îú‚îÄ‚îÄ user.rs       # User operations (via Pubky SDK)\n‚îÇ   ‚îú‚îÄ‚îÄ tools.rs      # Utilities (recovery, completions)\n‚îÇ   ‚îú‚îÄ‚îÄ util.rs       # Shared helpers\n‚îÇ   ‚îî‚îÄ‚îÄ main.rs       # CLI entry point\n‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îî‚îÄ‚îÄ integration.rs # E2E tests with pubky-testnet\n‚îî‚îÄ‚îÄ Cargo.toml\n\nDependencies\n\npubky SDK (0.6.0-rc.6): User-facing operations\npubky-testnet: Local testing harness\nclap: Command-line argument parsing\ntokio: Async runtime\n\nTroubleshooting\nConnection Issues\n# Verify homeserver is running\ncurl http://127.0.0.1:6287/\n \n# Check admin API\ncurl http://127.0.0.1:6288/\nRecovery File Errors\n# Ensure passphrase is correct\nPUBKY_CLI_RECOVERY_PASSPHRASE=wrong-pass pubky-cli user signin ./alice.recovery\n# Error: Failed to decrypt recovery file\n \n# Use correct passphrase\nPUBKY_CLI_RECOVERY_PASSPHRASE=correct-pass pubky-cli user signin ./alice.recovery\n# Success\nTestnet vs Production\n# Testnet (local development)\npubky-cli user signup $HOMESERVER_PK ./recovery --testnet\n \n# Production (requires full homeserver URL)\npubky-cli user signup $HOMESERVER_PK ./recovery\nLinks\n\nCrates.io: crates.io/crates/pubky-cli\nRepository: github.com/pubky/pubky-cli\nCI Status: GitHub Actions\nPubky SDK: docs.rs/pubky\n\nRelated Documentation\n\nPubky SDK - Client libraries for all platforms\nPubky Homeservers - Homeserver deployment and configuration\nPubky Docker - Full stack Docker environment\nPubky Core API - HTTP API specification\n"},"Explore/Technologies/PubkyDocker":{"title":"Pubky Docker","links":["explore/pubky-core/introduction","explore/pubky-app/backend/pubky-nexus","explore/pubky-app/introduction","explore/pubky-core/homeservers","explore/pubky-core/pkarr/0-introduction"],"tags":[],"content":"Pubky Docker is a Docker Compose orchestration that provides a one-click local development environment for running the complete Pubky Social (App) stack. It‚Äôs designed for developers who want to experiment with the full Pubky ecosystem or test components in an isolated environment.\nOverview\nPubky Docker orchestrates the following components:\n\nPkarr Relay - DHT relay for public key-addressable records\nPubky Homeserver - Decentralized data storage instance\nPubky Nexus - Social media indexer and aggregator\nPubky App - Social media client frontend\n\nThe orchestration includes all necessary supporting infrastructure (PostgreSQL, Neo4j, Redis) and is configurable for both testnet and mainnet environments.\nWhen to Use Pubky Docker\n‚úÖ Use Pubky Docker When:\n\nExperimenting with the complete Pubky Social stack\nDeveloping or testing Pubky Nexus integrations\nBuilding custom social media frontends\nTesting homeserver configurations\nLearning how all Pubky components interact\nDebugging cross-component issues\n\n‚ùå Don‚Äôt Use Pubky Docker When:\n\nBuilding applications using Pubky Core (use SDK libraries instead)\nDeveloping simple Pubky integrations (use official client libraries)\nJust testing basic read/write operations\n\nFor application development, use the official client libraries:\n\nJavaScript: @synonymdev/pubky\nRust: pubky\n\nQuick Start\nUsing Public Docker Images\nThis is the fastest way to get started. All images are available on Docker Hub.\n\nClone the repository:\n\ngit clone github.com/pubky/pubky-docker.git\ncd pubky-docker\n\nConfigure environment:\n\ncp .env-sample .env\n# Edit .env to set NETWORK=mainnet or NETWORK=testnet\n\nStart the stack:\n\ndocker compose up -d\nBuilding From Source\nIf you need to modify components or build custom versions:\n\nClone all required repositories at the same directory level:\n\n# Create a workspace directory\nmkdir pubky-workspace &amp;&amp; cd pubky-workspace\n \n# Clone all repositories\ngit clone github.com/pubky/pubky-docker.git\ngit clone github.com/pubky/pkarr.git\ngit clone github.com/pubky/pubky-core.git\ngit clone github.com/pubky/pubky-nexus.git\ngit clone github.com/pubky/pubky-app.git\n\nConfigure and start:\n\ncd pubky-docker\ncp .env-sample .env\n# Edit .env as needed\ndocker compose up\nThe directory structure must be:\npubky-workspace/\n‚îú‚îÄ‚îÄ pubky-docker/\n‚îú‚îÄ‚îÄ pkarr/\n‚îú‚îÄ‚îÄ pubky-core/\n‚îú‚îÄ‚îÄ pubky-nexus/\n‚îî‚îÄ‚îÄ pubky-app/\n\nStack Components\n1. Pkarr Relay (Port 6882)\nLocal DHT relay for public key-addressable resource records. Enables domain resolution for Pubky identities.\nConfiguration: pkarr.config.toml\n2. Pubky Homeserver (Ports 6287-6288, 15411-15412)\nLocal instance of a Pubky homeserver with PostgreSQL backend.\nConfiguration: homeserver.config.toml\nDatabase: PostgreSQL (Port 5432)\nEndpoints:\n\n6287: Primary HTTP API\n6286: Admin API\n6288: Metrics\n15411-15412: HTTP relay\n\n3. Pubky Nexus (Ports 8080-8081)\nSocial media indexer and aggregator with graph database and search capabilities.\nConfiguration: pubky-nexus-config-{testnet|mainnet}.toml\nDependencies:\n\nNeo4j graph database (Ports 7474, 7687)\nRedis search index (Ports 6379, 8001)\n\nEndpoints:\n\n8080: Main API\n8081: Admin/metrics\n\n4. Pubky App (Port 4200)\nNext.js-based social media frontend configured to use the local stack.\nAccess: http://localhost:4200\nConfiguration\nEnvironment Variables\nThe .env file controls key configuration:\n# Network Selection\nNETWORK=testnet  # or mainnet\n \n# Image Tags (when using public images)\nREGISTRY=synonymsoft\nPUBKY_APP_TAG=latest\nPUBKY_NEXUS_TAG=latest\nHOMESERVER_TAG=latest\nPKARR_TAG=latest\n \n# Database\nPOSTGRES_USER=homeserver\nPOSTGRES_PASSWORD=homeserver\nPOSTGRES_DB=homeserver\n \n# Frontend Configuration\nNEXT_PUBLIC_HOMESERVER=8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo\nNEXT_PUBLIC_NEXUS=http://localhost:8080\nNEXT_PUBLIC_TESTNET=true\nHTTP_RELAY=http://localhost:15412/link/\nNEXT_PUBLIC_PKARR_RELAYS=[&quot;pkarr.pubky.app&quot;,&quot;pkarr.pubky.org&quot;]\nNetwork Configuration\nThe stack uses a custom Docker bridge network (172.18.0.0/16) with static IPs:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nServiceIPExternal PortsPkarr172.18.0.26882Nexus172.18.0.38080, 8081Homeserver172.18.0.46286-6288, 15411-15412Neo4j172.18.0.57474, 7687Redis172.18.0.66379, 8001Client172.18.0.74200Postgres172.18.0.95432\nUsage Examples\nStart the Full Stack\ndocker compose up -d\nView Logs\n# All services\ndocker compose logs -f\n \n# Specific service\ndocker compose logs -f homeserver\ndocker compose logs -f nexusd\nStop the Stack\ndocker compose down\nRebuild After Code Changes\ndocker compose build\ndocker compose up -d\nReset All Data\ndocker compose down -v\nrm -rf .storage/\nDevelopment Workflows\nTesting Homeserver Changes\n\nModify code in ../pubky-core/\nRebuild homeserver:\n\ndocker compose build homeserver\ndocker compose up -d homeserver\nTesting Nexus Changes\n\nModify code in ../pubky-nexus/\nRebuild nexus:\n\ndocker compose build nexusd\ndocker compose up -d nexusd\nTesting Frontend Changes\n\nModify code in ../pubky-app/\nRebuild client:\n\ndocker compose build client\ndocker compose up -d client\nAccess Monitoring Tools\n\nNeo4j Browser: http://localhost:7474\nRedis Insight: http://localhost:8001\nPubky App: http://localhost:4200\n\nData Persistence\nAll data is stored in the .storage/ directory:\n.storage/\n‚îú‚îÄ‚îÄ pkarr/          # Pkarr relay cache\n‚îú‚îÄ‚îÄ postgres/       # Homeserver database\n‚îú‚îÄ‚îÄ neo4j/          # Nexus graph data\n‚îú‚îÄ‚îÄ redis/          # Nexus search index\n‚îî‚îÄ‚îÄ static/         # Nexus static files\n\nThis directory is gitignored. To reset your environment, simply delete it.\nTroubleshooting\nContainers Won‚Äôt Start\nCheck if ports are already in use:\n# Check port availability\nlsof -i :4200 -i :6882 -i :8080\nDatabase Connection Errors\nEnsure PostgreSQL is healthy:\ndocker compose ps postgres\ndocker compose logs postgres\nNexus Can‚Äôt Connect to Homeserver\nVerify homeserver is running and accessible:\ncurl http://localhost:6287/\ndocker compose logs homeserver\nReset a Specific Service\n# Stop service\ndocker compose stop nexusd\n \n# Remove its data\nrm -rf .storage/neo4j .storage/redis\n \n# Restart\ndocker compose up -d nexusd\nArchitecture\nThe Pubky Docker stack demonstrates the full architecture of a Pubky Social application:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                   Browser                           ‚îÇ\n‚îÇ              (localhost:4200)                       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                     ‚îÇ\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                Pubky App (Client)                   ‚îÇ\n‚îÇ            Next.js Frontend                         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ                      ‚îÇ\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ  Pubky Nexus     ‚îÇ   ‚îÇ Pubky Homeserver  ‚îÇ\n    ‚îÇ  (Social API)    ‚îÇ   ‚îÇ  (User Storage)   ‚îÇ\n    ‚îÇ  - Neo4j Graph   ‚îÇ   ‚îÇ  - PostgreSQL     ‚îÇ\n    ‚îÇ  - Redis Search  ‚îÇ   ‚îÇ  - File Storage   ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n             ‚îÇ                      ‚îÇ\n             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                        ‚îÇ\n                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                 ‚îÇ Pkarr Relay  ‚îÇ\n                 ‚îÇ (DHT/DNS)    ‚îÇ\n                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nLinks\n\nRepository: github.com/pubky/pubky-docker\nUpstream: github.com/pubky/pubky-docker\nDocker Hub: hub.docker.com/u/synonymsoft\n\nRelated Documentation\n\nPubky Core - Core protocol and SDK\nPubky Nexus - Social media indexer\nPubky App - Frontend application\nPubky Homeservers - Homeserver architecture\nPKARR - Public key addressable records\n"},"Explore/Technologies/PubkyExplorer":{"title":"Pubky Explorer","links":["Explore/PubkyCore/Homeserver","Explore/PubkyCore/SDK","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/PKDNS","Explore/PubkyApp/Introduction","Explore/PubkyApp/Backend/PubkyNexus","Explore/PubkyCore/API","FAQ"],"tags":[],"content":"Pubky Explorer is a web-based file browser for exploring public data stored on Pubky homeservers. It provides an intuitive interface for navigating the decentralized file system, previewing files, and sharing direct links to specific content‚Äîall without requiring authentication or installation.\nLive Application: explorer.pubky.app\nOverview\nPubky Explorer makes it easy to browse the public data stored across the Pubky network. Unlike traditional file explorers that require local access, Pubky Explorer operates entirely in the browser, fetching data directly from homeservers using the Pubky SDK.\nKey Features\n\nZero Installation: Runs entirely in the browser, no downloads required\nPublic Key Navigation: Enter any 52-character public key to browse their data\nDirectory Traversal: Navigate through nested directories like a traditional file browser\nFile Preview: View file contents directly in the browser (text, JSON, images)\nKeyboard Navigation: Full keyboard shortcuts for efficient browsing\nShareable URLs: Generate permanent links to specific files or directories\nSorting Options: Alphabetical sorting (A-Z, Z-A) with directories-first option\nShallow Mode: Limit directory depth for faster browsing\nResponsive Design: Works on desktop and mobile browsers\n\nHow It Works\nPubky Explorer uses the Pubky SDK to:\n\nResolve Public Keys: Convert public keys to homeserver URLs via PKARR\nList Directories: Fetch directory contents from homeservers\nFetch Files: Retrieve individual files for preview\nDisplay Content: Render files appropriately based on content type\n\nAll operations happen client-side in your browser‚Äîno data is sent to intermediary servers.\nUsage\nBasic Navigation\nEnter a Public Key:\n7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy\n\nWith Path:\n7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy/pub/pubky.app/\n\nWith URI Prefix:\npubky://7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy/\npk:7fmjpcuuzf54hw18bsgi3zihzyh4awseeuq5tmojefaezjbd64cy/\n\nURL Formats\nPubky Explorer supports multiple URL formats for sharing:\nQuery Parameter:\nexplorer.pubky.app\n\nHash Fragment:\nexplorer.pubky.app#p=&lt;public-key&gt;/&lt;path&gt;\n\nBoth formats work identically‚Äîchoose based on your preference for analytics or browser compatibility.\nKeyboard Shortcuts\nEfficient navigation without touching the mouse:\n\n‚Üë / ‚Üì: Navigate up/down through files and directories\nEnter: Open selected file/directory\nBackspace: Go to parent directory\n‚Üê / ‚Üí: Browser back/forward navigation\n/: Focus search input\n\nFile Actions\nDirectory Actions:\n\nClick directory name to enter it\nHover to prefetch contents for instant loading\nClick breadcrumb path to jump to parent directories\n\nFile Actions:\n\nClick file name to preview contents\nPreview opens in side panel\nClose preview to return to directory listing\n\nViewing Options\nShallow Mode:\n\nCheckbox option to limit recursion depth\nFaster loading for large directory structures\nUseful for quick exploration\n\nSorting:\n\nA-Z: Alphabetical ascending\nZ-A: Alphabetical descending\nDirs First: Group directories before files\n\nSharing\nShare Button:\n\nGenerates shareable URL for current view\nCopies to clipboard automatically\nIncludes exact path and file state\nRecipients see identical view\n\nUse Cases\nData Verification\nVerify published data structure:\n\nCheck if profile exists at expected path\nInspect post formatting and metadata\nValidate pubky-app-specs compliance\n\nDebugging\nDebug application issues:\n\nInspect actual stored data format\nCompare expected vs. actual file structure\nVerify permission issues aren‚Äôt data-related\n\nDiscovery\nExplore the Pubky network:\n\nBrowse public user data\nSee how applications structure data\nLearn common path conventions\n\nDocumentation\nCreate documentation with real examples:\n\nShare links to actual data structures\nReference real posts/profiles in tutorials\nProvide working examples for developers\n\nResearch\nStudy the Pubky ecosystem:\n\nAnalyze data usage patterns\nSurvey application conventions\nGather statistics on data types\n\nTechnical Details\nTechnology Stack\n\nFrontend Framework: SolidJS (reactive UI)\nBuild Tool: Vite (fast development and bundling)\nLanguage: TypeScript (type-safe development)\nPubky Integration: @synonymdev/pubky SDK\nStyling: CSS with modern features\n\nArchitecture\nClient-Side Only:\n\nNo backend server required\nAll data fetched directly from homeservers\nPrivacy-preserving (no tracking)\nCensorship-resistant (no proxy)\n\nState Management:\n\nReactive state using SolidJS signals\nDirectory listing cache for performance\nScroll position preservation\nBrowser history integration\n\nPerformance Optimizations:\n\nDirectory prefetching on hover/focus\nLazy loading for large directories\nIntersection observer for infinite scroll\nEfficient re-rendering with fine-grained reactivity\n\nData Flow\nUser Input ‚Üí SDK Resolution ‚Üí Homeserver Request ‚Üí Data Display\n    ‚Üì              ‚Üì                    ‚Üì                ‚Üì\nPublic Key    PKARR Lookup      HTTP/HTTPS        Render List\n  or Path       (via DHT)        (via SDK)       or Preview\n\nSupported File Types\nPreview Support:\n\nText: .txt, .md, .log\nCode: .js, .ts, .json, .html, .css\nData: .json, .yaml, .xml\nImages: .jpg, .png, .gif, .svg, .webp\nDocuments: Raw text rendering for inspection\n\nDownload Fallback:\n\nBinary files prompt download\nLarge files may timeout (browser limits)\nUnknown types rendered as text when possible\n\nDevelopment\nLocal Setup\n# Clone repository\ngit clone github.com/pubky/pubky-explorer\ncd pubky-explorer\n \n# Install dependencies\nnpm install\n \n# Start development server\nnpm run dev\n \n# Open browser to http://localhost:5173\nBuilding for Production\n# Build optimized bundle\nnpm run build\n \n# Preview production build\nnpm run preview\nOutput in dist/ directory ready for static hosting.\nProject Structure\npubky-explorer/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ App.tsx           # Main application component\n‚îÇ   ‚îú‚îÄ‚îÄ Explorer.tsx      # Directory browser UI\n‚îÇ   ‚îú‚îÄ‚îÄ Preview.tsx       # File preview panel\n‚îÇ   ‚îú‚îÄ‚îÄ ShareButton.tsx   # Share URL generator\n‚îÇ   ‚îú‚îÄ‚îÄ Spinner.tsx       # Loading indicator\n‚îÇ   ‚îú‚îÄ‚îÄ state.ts          # Global state management\n‚îÇ   ‚îî‚îÄ‚îÄ css/              # Component styles\n‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îî‚îÄ‚îÄ pubky.svg         # Logo asset\n‚îú‚îÄ‚îÄ index.html            # HTML entry point\n‚îú‚îÄ‚îÄ vite.config.ts        # Vite configuration\n‚îî‚îÄ‚îÄ package.json          # Dependencies\n\nConfiguration\nEnvironment Variables:\nNone required! Pubky Explorer works entirely with the public Pubky SDK and requires no API keys or configuration.\nDeployment:\nDeploy to any static hosting service:\n\nVercel: vercel deploy\nNetlify: Drag &amp; drop dist/ folder\nGitHub Pages: Push dist/ to gh-pages branch\nCloudflare Pages: Connect repository\nAWS S3: Upload dist/ contents\n\nPrivacy &amp; Security\nPrivacy Features\n\nNo Analytics: Zero tracking by default\nNo Cookies: Stateless operation\nNo Server: Direct homeserver connections\nClient-Side: All computation in browser\nNo Data Collection: Nothing stored externally\n\nSecurity Considerations\n\nPublic Data Only: Only displays public homeserver data\nNo Authentication: Cannot access private data\nRead-Only: Cannot modify or upload data\nCORS Limitations: Subject to homeserver CORS policies\nBrowser Sandbox: Runs in browser security context\n\nData Visibility\nWhat Explorer Can See:\n\nPublic directories on homeservers\nFiles with read permissions\nMetadata (file sizes, structure)\n\nWhat Explorer Cannot See:\n\nPrivate or encrypted data\nAuthentication-required content\nData without proper CORS headers\n\nLimitations\nTechnical Constraints\n\nLarge Files: Browser memory limits may cause issues\nMany Files: Extremely large directories may be slow\nBinary Files: Limited preview support for binary formats\nRecursive Depth: Deep nesting may impact performance\nNetwork Speed: Limited by homeserver response times\n\nFunctional Limitations\n\nRead-Only: No upload or edit capabilities\nNo Authentication: Cannot access private data\nPublic Data: Only works with publicly readable content\nCORS Dependent: Requires homeserver CORS support\nSingle Homeserver: No multi-homeserver aggregation\n\nFuture Enhancements\nPotential improvements for Pubky Explorer:\n\nFile Upload: Enable data publishing (with authentication)\nEditing: In-browser file editing with SDK write operations\nSearch: Full-text search across user‚Äôs data\nHistory: Recent locations and favorites\nBulk Operations: Select multiple files for actions\nAdvanced Preview: Markdown rendering, syntax highlighting\nData Visualization: Charts for JSON data, image galleries\nComparison View: Diff between file versions\nMobile App: Native iOS/Android applications\nOffline Support: Service worker for caching\n\nRelated Tools\n\nPubky SDK: Underlying data access library\nPKDNS: DNS resolution for public keys (used by SDK)\nPubky App: Social application using same data structures\npubky-app-specs: Data model specifications\nPubky Nexus: Backend for aggregated views (Explorer shows raw data)\n\nResources\n\nLive Application: explorer.pubky.app\nRepository: github.com/pubky/pubky-explorer\nSolidJS Documentation: solidjs.com\nVite Documentation: vitejs.dev\n\nSee Also\n\nHomeserver - Data storage explained\nPubky Core SDK - How data access works\nPubky Core API - Homeserver HTTP API\nPKARR - Public key resolution\nQ14a - FAQ entry about exploring data\n"},"Explore/Technologies/PubkyNoise":{"title":"Pubky Noise","links":["Explore/Technologies/KeyPair","Explore/PubkyCore/Homeserver","Explore/Technologies/Paykit","Explore/Technologies/PubkyRing"],"tags":[],"content":"Encrypted Communication Protocol\n\n‚ö†Ô∏è NOTE: Pubky Noise is currently under active development and is NOT production-ready. The protocol implementation is subject to changes and improvements.\n\nOverview\nPubky Noise is a Noise Protocol implementation designed specifically for the Pubky ecosystem. It provides encrypted, authenticated communication channels for peer-to-peer applications built on Pubky.\nWhat is the Noise Protocol?\nThe Noise Protocol Framework is a modern cryptographic framework for building secure communication protocols. It‚Äôs used by WhatsApp, WireGuard, and other high-security applications.\nKey Properties:\n\nForward secrecy\nMutual authentication\nMinimal round-trips\nSimple, auditable implementation\nResistance to replay attacks\n\nPubky Noise Implementation\nPubky Noise adapts the Noise Protocol for use with Pubky‚Äôs Ed25519 identity keys, providing seamless integration with the Pubky ecosystem.\nHandshake Pattern\nPubky Noise uses the IK (Interactive, Known responder) handshake pattern:\n\nInitiator ‚Üí Responder: Initiator‚Äôs ephemeral key + encrypted static key\nResponder ‚Üí Initiator: Responder‚Äôs ephemeral key + encrypted response\nBoth: Derive shared secret and establish encrypted channel\n\nThis three-step handshake provides:\n\nMutual authentication (both parties verify each other)\nForward secrecy (compromise of long-term keys doesn‚Äôt reveal past messages)\nMinimal latency (only 1.5 round-trips)\n\nKey Features (Work in Progress)\nCryptographic Primitives:\n\nX25519: Elliptic curve Diffie-Hellman key exchange\nChaCha20-Poly1305: Authenticated encryption with associated data (AEAD)\nBLAKE2b: Cryptographic hash function\nHKDF: Key derivation from Ed25519 to X25519\n\nTransport Support:\n\nTCP connections for server/desktop applications\nWebSocket support for browser applications\nPlatform-specific adapters (iOS, Android, Web, CLI)\n\nSession Management:\n\nPersistent sessions with session IDs\nReconnection support\nSession expiration handling\nRate limiting per connection\n\nIntegration:\n\nDerives encryption keys from Pubky Ed25519 identities\nPublishes Noise endpoints to homeserver directories\nAutomatic peer discovery via Pubky public keys\nCompatible with Paykit payment protocol\n\nSecurity Properties\nConfidentiality: All messages encrypted end-to-end with ChaCha20-Poly1305\nAuthentication: Both parties cryptographically verified using Pubky identities\nForward Secrecy: Ephemeral keys protect past communications\nReplay Protection: Nonce-based message authentication\nIntegrity: Poly1305 MAC prevents message tampering\nUse Cases\nPayment Negotiation\nPaykit uses Pubky Noise for private payment coordination:\n\nExchange payment requests securely\nShare sensitive payment details (invoices, addresses)\nCoordinate subscription agreements\nReceipt exchange and verification\n\nPrivate Messaging (Potential)\nWhile not yet implemented, Pubky Noise could support:\n\nDirect messages between Pubky users\nGroup messaging with multiple participants\nFile transfer over encrypted channels\nVoice/video call signaling\n\nSecure Data Exchange (Potential)\n\nPrivate content sharing\nEncrypted file storage coordination\nAPI authentication and authorization\nCross-device synchronization\n\nArchitecture\nEndpoint Discovery\nNoise endpoints are published to homeservers at:\n/pub/paykit.app/v0/noise\n\nThis public endpoint contains:\n\nHost address (IP or domain)\nPort number\nPublic key for encryption\nTransport type (TCP, WebSocket)\n\nConnection Flow\n1. Client queries homeserver for recipient&#039;s Noise endpoint\n2. Client initiates connection to endpoint\n3. IK handshake establishes encrypted channel\n4. Application-specific protocol runs over encrypted channel\n5. Session maintained or closed per application needs\n\nKey Derivation\nPubky Noise derives X25519 encryption keys from Ed25519 identity keys (managed by Pubky Ring):\nEd25519 Identity Key (Pubky)\n    ‚Üì (HKDF with context)\nX25519 Encryption Key (Noise Protocol)\n\nThis allows users to use their existing Pubky identity for encrypted communications without managing separate keys. Pubky Ring handles this derivation automatically when apps request Noise keys.\nPlatform Support\niOS\n\nNative Swift bindings via UniFFI\nKeychain integration for key storage\nBackground session support\nNetwork state handling\n\nAndroid\n\nNative Kotlin bindings via UniFFI\nEncryptedSharedPreferences for key storage\nForeground service support\nNetwork change adaptation\n\nWeb (WASM)\n\nWebAssembly compilation\nWebSocket transport\nBrowser secure storage\nService worker integration\n\nCLI/Server\n\nTCP transport\nFile-based session storage\nLong-running server mode\nComprehensive logging\n\nCurrent Status\nWork in Progress:\n\nüöß Core protocol implementation under development\nüöß Platform bindings being refined\nüöß Session management improvements\nüöß Performance optimization ongoing\nüöß Security audit pending\n\nTesting Integrations:\n\nIntegrated in Paykit for payment channels\nTesting in Bitkit iOS and Android\nDemo applications available\nCross-platform compatibility validation\n\nTechnical Specifications\nMessage Format\n[2 bytes: message length]\n[N bytes: encrypted payload]\n[16 bytes: authentication tag]\n\nSession State\n\nSending nonce counter\nReceiving nonce counter\nShared secret key (ChaCha20)\nSession ID\nPeer public key\n\nTransport Framing\nMessages are length-prefixed and encrypted in sequence, maintaining order and preventing replay.\nRelationship to Pubky Core\nPubky Noise is a communication layer for Pubky:\n\nUses Pubky identity system (Ed25519 keys)\nPublishes endpoints to homeservers\nIntegrates with Pubky discovery mechanisms\nEnables private peer-to-peer protocols on top of public Pubky infrastructure\n\nSecurity Considerations\nThreat Model\n\nMan-in-the-Middle: Prevented by authenticated handshake\nReplay Attacks: Prevented by nonce counters\nEavesdropping: Prevented by encryption\nImpersonation: Prevented by key authentication\n\nNot Protected Against\n\nTraffic Analysis: Connection metadata is visible\nDenial of Service: Rate limiting helps but doesn‚Äôt fully prevent\nKey Compromise: If private keys are stolen, future communications are vulnerable\n\nBest Practices\n\nRotate sessions periodically\nUse platform-native secure storage\nImplement rate limiting\nMonitor for unusual connection patterns\nValidate peer identities through Pubky social graph\n\nFuture Development\n\nEnhanced session persistence\nMulti-party encrypted channels\nTransport protocol optimization\nAdditional platform support\nFormal security audit\nPerformance benchmarking\n\n\n‚ö†Ô∏è Important: Do not use Pubky Noise in production applications yet. The implementation is a work in progress and subject to security review and potential breaking changes.\nLinks\n\nRepository (WIP): github.com/BitcoinErrorLog/pubky-noise\nNoise Protocol Framework: noiseprotocol.org/\n\nRelated Documentation\n\nPaykit - Uses Pubky Noise for payment negotiation channels\nPubky Ring - Manages Noise endpoints and sessions\n"},"Explore/Technologies/PubkyRing":{"title":"Pubky Ring","links":["Explore/Technologies/KeyPair","Explore/PubkyCore/Homeserver","Explore/Technologies/PubkyNoise","Explore/Technologies/Paykit","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT"],"tags":[],"content":"Pubky Ring: Identity Manager for Pubky\n\nYour keychain for the Pubky ecosystem. Manage your pubkys, authorize services, and stay in control‚Äîno accounts, no passwords.\n\nOverview\nPubky Ring is the key manager and identity application for the Pubky ecosystem. It‚Äôs a native mobile app (iOS and Android) that lets you securely manage your pubkys‚Äîthe public keys that power your presence across decentralized applications.\nCore Philosophy:\n\nSelf-custodial: You control your keys, no one else\nNo accounts: No usernames, no passwords, no registration\nNo tracking: Your identity data stays on your device\nInteroperable: Works seamlessly with Pubky apps\n\nWhat You Can Do\nIdentity Management\n\nCreate and manage multiple pubkys: Each identity is a separate public key\nOrganize identities: Label and categorize your different personas\nSwitch between identities: Seamlessly use different pubkys for different contexts\nBackup and restore: Secure backup of your keys with recovery options\n\nService Authorization\n\nAuthorize apps: Grant specific permissions to Pubky applications\nRevoke access: Instantly remove app permissions\nSession management: View and control all active sessions\nGranular permissions: Choose what each app can access\n\nCross-Device Sync\n\nSync across devices: Keep your identities consistent between phone and tablet\nSecure synchronization: Encrypted sync using homeserver storage\nMulti-device sessions: Use the same identity on multiple devices simultaneously\n\nKey Derivation Services\n\nEd25519 identity keys: Primary Pubky identity keys\nX25519 Noise keys: Automatically derived for encrypted communication\nSession keys: Temporary keys for app sessions\nPayment keys: Support for payment protocol integration\n\nArchitecture\nNative Mobile App\nPubky Ring is built with React Native, providing:\n\nNative performance on iOS and Android\nPlatform-specific secure storage (Keychain/Keystore)\nDeep linking support for app integration\nBackground services for session management\n\nKey Storage\niOS:\n\nKeychain Services for secure key storage\nHardware-backed encryption when available\nBiometric authentication (Face ID/Touch ID)\nSecure Enclave integration\n\nAndroid:\n\nEncryptedSharedPreferences with hardware-backed keystore\nBiometric authentication (fingerprint/face unlock)\nStrongBox Keymaster support on compatible devices\n\nSession Management\nPubky Ring manages authentication sessions for connected apps:\n\nSession creation with capability tokens\nSession expiration and renewal\nMulti-device session coordination\nSession revocation\n\nDeep Linking &amp; Integration\nPaykit Connect (paykit-connect://)\nPubky Ring provides deep link handlers for Paykit integration:\npaykit-connect://[callback-url]?[parameters]\n\nFlow:\n\nBitkit (or other wallet) requests Paykit authorization\nOpens Pubky Ring via deep link\nUser approves in Pubky Ring\nRing derives Noise keys and creates session\nReturns encrypted session data via callback\nWallet receives authorization and can use Paykit\n\nParameters:\n\ncallback_url: Where to return authorization data\napp_name: Requesting application name\npermissions: Requested capabilities\nsession_duration: Requested session lifetime\n\nOther Deep Links\n\npubky:// - General Pubky protocol handler\npkarr:// - PKARR resolution requests\nCustom app-specific handlers\n\nNoise Key Derivation\nPubky Ring derives X25519 encryption keys from Ed25519 identity keys using HKDF:\nEd25519 Identity Key (32 bytes)\n    ‚Üì HKDF-SHA256 with context &quot;pubky-noise-v1&quot;\nX25519 Static Key (32 bytes)\n    ‚Üì Used for Noise Protocol IK handshake\nEncrypted Communication Channel\n\nThis allows apps to:\n\nUse a single identity for both signing and encryption\nDerive consistent encryption keys across devices\nMaintain forward secrecy through ephemeral keys\nAuthenticate with Pubky identity system\n\nIntegration with Paykit\nPaykit uses Pubky Ring for:\nSession Creation:\n\nUser authenticates in Ring\nRing generates session credentials\nEncrypted session returned to wallet\nWallet can now use Paykit features\n\nKey Management:\n\nRing stores master Ed25519 key\nDerives X25519 keys for Noise channels\nManages session rotation\nHandles key backup/recovery\n\nCross-Device Authentication:\n\nRing polls relay for pending auth requests\nUser approves on trusted device\nSession synchronized via encrypted relay\nWallet receives authorization on new device\n\nSee the Bitkit + Paykit Integration Master Guide for detailed integration documentation.\nTechnical Specifications\nSupported Platforms\n\niOS: 13.0+\nAndroid: API level 24+ (Android 7.0)\nReact Native: 0.74+\n\nStorage Format\nKeys are stored in encrypted format:\n{\n  &quot;version&quot;: &quot;1&quot;,\n  &quot;identities&quot;: [\n    {\n      &quot;id&quot;: &quot;unique-id&quot;,\n      &quot;label&quot;: &quot;My Main Identity&quot;,\n      &quot;publicKey&quot;: &quot;8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo&quot;,\n      &quot;created&quot;: &quot;2024-01-01T00:00:00Z&quot;,\n      &quot;lastUsed&quot;: &quot;2024-01-05T12:30:00Z&quot;\n    }\n  ],\n  &quot;sessions&quot;: [...],\n  &quot;settings&quot;: {...}\n}\nPrivate keys never leave the secure storage.\nSecurity Model\nThreat Protection:\n\n‚úÖ Key theft via malware (hardware-backed storage)\n‚úÖ Unauthorized app access (user approval required)\n‚úÖ Man-in-the-middle (cryptographic authentication)\n‚úÖ Session hijacking (time-limited sessions, rotation)\n\nTrust Assumptions:\n\nDevice OS is secure and not compromised\nUser approves legitimate authorization requests\nBiometric authentication is properly secured\nSecure storage implementation is sound\n\nAttack Surface:\n\nDeep link handlers (validated and sanitized)\nSession relay communication (encrypted)\nBackup/restore process (user must secure backup)\n\nUser Experience\nOnboarding Flow\n\nInstall Pubky Ring from app store\nCreate first identity - generates Ed25519 keypair\nSet up security - enable biometrics, set PIN\nBackup keys - secure recovery phrase or encrypted backup\nConnect apps - authorize Pubky applications\n\nDaily Usage\n\nQuick authorization: Biometric approval for app requests\nSession overview: See all connected apps and active sessions\nIdentity switching: Tap to switch between personas\nPermission management: Review and adjust app permissions\n\nPrivacy Features\n\nLocal-first: All data stored on device\nNo telemetry: No analytics or tracking\nNo cloud sync (unless user enables encrypted sync)\nAnonymous: No registration, no personal information required\n\nDevelopment &amp; Testing\nLocal Development\n# Clone repository\ngit clone github.com/pubky/pubky-ring\ncd pubky-ring\n \n# Install dependencies\nyarn install\ncd ios &amp;&amp; pod install &amp;&amp; cd ..\n \n# Run on iOS\nyarn ios\n \n# Run on Android\nyarn android\nE2E Testing\nPubky Ring includes Appium/WebdriverIO tests:\n# Install test drivers\nyarn e2e:drivers\n \n# Run Android tests\nyarn e2e:android\n \n# Run iOS tests\nyarn e2e:ios\nEnvironment Variables\n\nANDROID_APP: Path to APK for testing\nIOS_APP: Path to .app for testing\nAVD: Android Virtual Device name\nIOS_SIM: iOS Simulator name\n\nRelationship to Pubky Ecosystem\nPubky Ring is the identity foundation for:\nPubky Core\n\nManages Ed25519 identity keys\nPublishes keys via PKARR to Mainline DHT\nAuthorizes apps to store data on homeservers\n\nPubky App\n\nProvides identity for social graph\nAuthorizes content publishing\nManages following/follower relationships\n\nPaykit\n\nCreates payment sessions\nDerives Noise encryption keys\nAuthorizes payment operations\nManages subscription agreements\n\nPubky Noise\n\nDerives X25519 keys for encryption\nManages Noise endpoint publishing\nHandles encrypted channel sessions\n\nRepository\n\nOfficial: github.com/pubky/pubky-ring\n\nRelease Verification\nVerify APK Authenticity\n# Import maintainer&#039;s GPG key\ngpg --import public-key.asc\n \n# Verify signature\ngpg --verify app-release.apk.asc app-release.apk\n \n# Verify checksum\ngpg --verify SHA256SUMS.asc\nsha256sum -c SHA256SUMS\nAlways verify releases to ensure you‚Äôre installing authentic, untampered builds.\nRoadmap &amp; Future Features\nPlanned Enhancements:\n\nMulti-signature support for shared identities\nHardware wallet integration\nDecentralized identity recovery (social recovery)\nAdvanced permission models\nIdentity attestations and verification\nIntegration with more Pubky applications\n\nResearch Areas:\n\nZero-knowledge proofs for privacy-preserving authorization\nThreshold cryptography for distributed key management\nPost-quantum cryptography readiness\nAdvanced session policies\n\n\nPubky Ring is the secure, self-custodial foundation for your presence in the Pubky ecosystem. Download it to get started with decentralized identity management."},"Explore/index":{"title":"index","links":["Explore/PubkyCore/Introduction","Explore/PubkyApp/Introduction","Explore/Technologies/MainlineDHT","Explore/Concepts/CredibleExit"],"tags":[],"content":"Explore\n\nPubky Core\nPubky App\nTechnologies\nConcepts\n"},"FAQ":{"title":"FAQ","links":["Explore/PubkyCore/Introduction","Explore/PubkyCore/SDK","Explore/Technologies/PKDNS","Explore/PubkyCore/Pkarr/0.Introduction","Explore/Technologies/MainlineDHT","Explore/Technologies/PubkyExplorer","Explore/Technologies/PubkyDocker","Explore/Technologies/PubkyRing","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/Homegate","Explore/Technologies/PubkyNoise","Explore/Technologies/Paykit"],"tags":[],"content":"Pubky Core - Frequently Asked Questions\nOverview &amp; Philosophy\nQ1. What is Pubky, and why was it developed?\nPubky is a new kind of web built on public key domains instead of usernames or rented accounts. Your public key becomes your self-sovereign domain. Pubky uses PKDNS, which runs on the Mainline DHT.\nPubky introduces a semantic social graph driven by tags and trust, not ads and opaque feeds.\nIt was created to counter:\n\nPoisoned algorithms\nCensorship\nWalled gardens and data harvesting\n\nQ2. Why is Pubky critical for a free-market society?\nBecause it removes gatekeepers by design. Identities are user-owned; hosting/indexing are interchangeable.\nQ3. What‚Äôs the relationship between Pubky and Slashtags?\nSlashtags was a previous Synonym project using Hypercore instead of PKDNS and homeservers. It shared similar goals.\nQ4. Is Pubky open source?\nYes. Under the MIT license. View on GitHub\nQ5. What is Pubky Core?\nPubky Core is the foundational infrastructure for Pubky - an open protocol combining censorship-resistant public-key DNS (PKARR) with conventional web technologies. It includes the protocol specification, a production-ready homeserver implementation, and SDKs in multiple languages (Rust, JavaScript, iOS, Android). See the Pubky Core Overview for details.\nQ6. How do I start building on Pubky?\nInstall the Pubky SDK for your platform (Rust: cargo add pubky, JavaScript: npm install @synonymdev/pubky), follow the official documentation, and explore the examples in the repository. The SDK provides client libraries for authentication, data storage, and homeserver interaction.\n\nArchitecture &amp; Resolution (PKARR, PKDNS, DHT)\nQ7. What is PKARR?\n‚ÄùPublic Key Addressable Resource Records‚Äù your signed DNS-like records published on the DHT.\nQ8. What is PKDNS?\nPKDNS is a DNS server that resolves public key domains by fetching PKARR records from the Mainline DHT. It enables self-sovereign, censorship-resistant domain names while still supporting traditional ICANN domains. Anyone can run a PKDNS server or use public instances to access the decentralized web. See PKDNS for setup guides and publishing instructions.\nQ9. How does Pubky compare to DNS?\nPubky replaces ICANN with your public key. You publish and resolve records yourself.\nQ10. What format does PKDNS use?\nDNS-style RR, signed under your key, shared via the Mainline DHT.\nQ11. Does it support CNAME/SRV/HTTPS indirection?\nYes, with caveats, avoid deep/brittle recursion.\nQ12. Are DHTs part of the clearnet?\nYes, via UDP. Web browsers require bridges due to lack of raw UDP support.\nQ13. How can browsers interact with the DHT?\nVia HTTP bridges, resolvers like PKDNS, or native helpers.\nQ14. Do others need PKDNS to connect to Pubky sites?\nNo special setup in the Pubky App. Other apps can use public PKDNS instances or self-hosted PKDNS resolvers. Many public DNS-over-HTTPS endpoints are available‚Äîsee the PKDNS documentation for a list of hosted servers.\n\nHomeservers &amp; Hosting\nQ15. What are homeservers?\nRegular web servers that host your content. Anyone can run one.\nQ16. Can I run one at home?\nYes. You‚Äôll need port forwarding or tunneling if behind NAT.\nQ17. How can I explore data on a homeserver?\nUse Pubky Explorer (explorer.pubky.app), a web-based file browser for public Pubky data. Enter any public key or path (e.g., pubky://your-key/pub/pubky.app/profile.json) to browse files and directories stored on homeservers. Features include keyboard navigation, file preview, directory traversal, and shareable URLs.\nQ18. How can I run the complete Pubky stack locally for development?\nUse Pubky Docker, a Docker Compose orchestration that runs the entire Pubky Social stack with one command. It includes Pkarr relay, homeserver (with PostgreSQL), Pubky Nexus (with Neo4j and Redis), and the Pubky App frontend‚Äîall preconfigured and ready to use. Clone the repository, configure .env for testnet or mainnet, and run docker compose up -d. Perfect for testing integrations, developing custom frontends, or learning how all components interact. See Pubky Docker for setup instructions.\nQ19. When should I use Pubky Docker vs SDK libraries?\nUse the SDK libraries (@synonymdev/pubky for JavaScript, pubky for Rust) when building applications that interact with Pubky. Only use Pubky Docker if you need to run the full stack locally to experiment with Pubky Nexus, test custom social frontends, debug cross-component issues, or learn the complete architecture. For most app development, the SDK libraries connected to public infrastructure are simpler and faster.\nQ20. How is redundancy handled?\nUse mirrors in PKARR. Clients pick healthy ones.\nQ21. Does it support load balancing?\nYes, for reads. Writes go to a single primary.\nQ22. Can homeservers sign my data?\nNo. Signing is done by the client.\nQ23. How to self-host a homeserver?\nDeploy the package/container, configure HTTPS, publish in PKARR.\nQ24. What are the storage limits?\nSynonym‚Äôs public homeserver currently has: 1GB per user, 10MB per file. These are temporary limits during beta. Self-hosted homeservers can configure their own limits.\nQ25. Can Pubky integrate with Tor?\nYes, via .onion endpoints, but it‚Äôs not yet tested officially.\n\nIdentity, Keys &amp; Security\nQ25. How are keys managed?\nWith Pubky Ring, the identity manager app for Pubky. Pubky Ring is a native mobile app (iOS/Android) that securely manages your pubkys (public keys), handles device sessions, publishes identity via PKARR, and authorizes apps‚Äîall without accounts or passwords.\nQ26. Does Pubky support key rotation?\nNot yet standardized, possible manually via PKARR fallback logic.\nQ27. What if my key is lost or hacked?\nMigrate to a new key, update PKARR, and alert your graph.\nQ28. Can I use the same seed as Nostr?\nYes, but most users prefer separate secrets due to risk.\nQ29. How does identity trust work?\nNo global authority, trust is built through social graph, tags, and interaction.\n\nPublishing, Privacy &amp; Moderation\nQ30. How do I publish content?\nHost it on a homeserver and link it in your PKARR.\nQ31. Is Pubky suitable for private sharing?\nNot yet. All current use assumes public content.\nQ32. Where does moderation happen?\nAt the homeserver and indexer level (e.g., Pubky Nexus).\nQ33. What is Pubky Nexus?\nPubky Nexus is the production indexing and aggregation service that powers Pubky App. It transforms data from multiple homeservers into a high-performance social graph API with sub-millisecond response times, enabling features like feeds, search, recommendations, and real-time notifications. Explore the live API.\nQ34. Can I run my own Nexus instance?\nYes! Nexus is open source and can be self-hosted. This allows organizations to run custom instances with their own content filtering policies, moderation rules, and homeserver selections. See the Pubky Nexus documentation for deployment details.\nQ35. How does Pubky resist spam?\nVia CAPTCHAs, rate-limits, invites, and graph distance rules.\nQ36. How does Paykit fit in?\nPaykit is a payment protocol (work in progress) built on Pubky that aims to enable payment discovery and coordination across multiple methods (Bitcoin, Lightning, etc.). It‚Äôs currently being tested through integrations in Bitkit iOS and Android, with planned features including:\n\nDirect peer-to-peer payments using Pubky identities\nEncrypted payment negotiation via Noise Protocol\nSubscriptions with auto-pay and spending limits\nContent monetization capabilities (paywalls, tips, micropayments)\n\n‚ö†Ô∏è Note: Paykit is NOT production-ready and the protocol is subject to significant changes.\nQ37. Is Paykit ready for use?\nNo. Paykit is currently a work in progress under active development. The protocol specification, security model, and implementation are all subject to breaking changes. Do not use it for production applications.\nQ38. What payment methods will Paykit support?\nThe initial focus is on Bitcoin on-chain and Lightning Network. The protocol is designed to be extensible to other methods (Liquid, Fedimint, ecash, etc.), but these are not yet implemented or specified.\nQ39. Where is Paykit being tested?\nPaykit is being integrated into Bitkit (iOS and Android) to validate the protocol design and identify issues before stabilization. These integrations serve as testbeds, not production features.\nQ40. When will Paykit be production-ready?\nThere is no set timeline. Significant work remains on protocol stabilization, security auditing, cross-platform testing, and interoperability validation before Paykit can be recommended for production use.\nQ41. Can Pubky do everything Nostr can?\nYes, and more. Pubky includes DHT-based discovery and semantic tagging.\n\nInteroperability, Ecosystem &amp; Onboarding\nQ42. Pubky vs IPFS\nPubky is identity-first and mutable; IPFS is content-first and immutable.\nQ43. Pubky vs Nostr\nPubky uses homeservers and PKARR for hosting; Nostr uses relays. Pubky has semantic discovery.\nQ44. Pubky vs Bluesky\nPubky is key-native and decentralized. Bluesky relies on DID directories and centralized servers.\nQ45. Pubky vs Farcaster\nPubky = key-owned + off-chain. Farcaster = chain-anchored + relay-dependent.\nQ46. Will Pubky integrate with other protocols?\nBridges are possible, but not currently in development.\nQ47. Are there mobile apps?\nYes!\n\nPubky Ring: Native mobile app (iOS/Android) - Your keychain for the Pubky ecosystem. Manages identities, authorizes apps, and handles sessions. Self-custodial with no accounts required.\nPubky.app: Progressive Web App (PWA) - Social publishing application\nMore apps welcome from the community!\n\nQ48. What is Pubky Ring?\nPubky Ring is the key manager app for the Pubky ecosystem. It‚Äôs a native mobile app (iOS/Android) that securely manages your pubkys (public keys), authorizes applications, manages sessions, and handles key derivation‚Äîall self-custodially with no accounts, passwords, or tracking. Think of it as your keychain for decentralized identity.\nQ49. How do users join Pubky App?\nHomeservers can implement signup verification to prevent spam while preserving privacy. Homegate is an open-source service that provides two verification methods: SMS codes (rate-limited per phone number) and Lightning Network payments. Homeserver operators can use Homegate, implement custom verification, or allow open signups. See Homegate for deployment and integration details.\nQ50. Indexer vs Homeserver?\n\nHomeserver = stores user data\nIndexer = enables search/feeds across homeservers\n\nQ51. How do I ensure my app is compatible with Pubky App?\nFollow the pubky-app-specs data model specification. This defines the structure and validation rules for users, posts, tags, bookmarks, follows, and feeds. The spec is available as an npm package (JavaScript/TypeScript) and Rust crates. Note: Currently v0.4.0 in rapid development; v1 will mark the first stable, long-term support version.\nQ52. What‚Äôs the status of Pubky App development?\nThe current Pubky App client (pubky.app) is operational as an MVP but the codebase is deprecated. A next-generation client called Franky is under development and expected summer 2025. The new implementation will focus on improved reliability, scalability, and user experience. Developers building compatible clients should use pubky-app-specs as the authoritative specification rather than the transitional codebase.\nQ53. Can I contribute to Pubky App?\nThe original pubky-app repository is deprecated and no longer accepting code contributions (marked as ‚Äúdead-end repository‚Äù by the team). Bug reports are welcome, but development efforts should focus on the upcoming Franky repository once it‚Äôs ready for contributions. If you want to build a compatible social client now, use the pubky-app-specs specification as your foundation.\n\nOperations, Resilience &amp; Scale\nQ54. How do I migrate providers?\nAdd mirror ‚Üí update PKARR ‚Üí let caches sync ‚Üí retire old host.\nQ55. What if Synonym disappears?\nNothing breaks. Your key, data, and graph are yours.\nQ56. What if my ISP censors my homeserver?\nSwitch hosts, use Tor/VPN, republish PKARR.\nQ57. How often does PKARR update?\nPeriodically, every few hours is typical. See republishing research for details.\nQ58. What if I spam the DHT?\nYou‚Äôll be rate-limited. Publish sensibly.\nQ59. Does DHT scale globally?\nYes. Mainline DHT already does, Pubky‚Äôs usage is lightweight.\nQ60. Why do some say Nostr needs a DHT?\nBecause relay-only networks don‚Äôt scale easily without coordination.\nQ61. What about private data in Pubky?\nShort-term: Pubky Noise-based encrypted channels for private peer-to-peer communication.\nLong-term: Cryptree-style systems and further R&amp;D.\nQ62. What is Pubky Noise?\nPubky Noise is a Noise Protocol implementation that provides encrypted communication channels for the Pubky ecosystem. It uses the IK handshake pattern for mutual authentication and forward secrecy. Currently used by Paykit for private payment negotiation, it can also support other applications requiring secure peer-to-peer communication. Work in progress - not production-ready yet.\nQ63. How does Pubky Noise differ from the Noise Protocol?\nPubky Noise is a specific implementation of the Noise Protocol Framework adapted for the Pubky ecosystem. It integrates with Pubky‚Äôs Ed25519 identity system, derives X25519 encryption keys automatically, and publishes endpoints to homeserver directories for peer discovery. It provides platform-specific bindings (iOS, Android, Web, CLI) and handles session management.\n"},"GettingStarted":{"title":"Getting Started","links":["Explore/Technologies/PubkyRing","Explore/Technologies/PubkyExplorer","FAQ","Explore/PubkyCore/ELI5","Explore/Concepts/SemanticSocialGraph","Explore/PubkyCore/SDK","Explore/Technologies/PubkyDocker","Explore/Technologies/PubkyCLI","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/Paykit","Explore/Technologies/PubkyNoise","Explore/PubkyCore/Homeserver","Explore/Technologies/Homegate","Explore/Technologies/PKDNS","Explore/PubkyCore/Introduction","Architecture","Comparisons","Troubleshooting","Explore/PubkyCore/Authentication","/","Glossary","TLDR","Explore/PubkyCore/API"],"tags":[],"content":"Getting Started with Pubky\nWelcome to Pubky! This guide will help you get started whether you‚Äôre a user looking to try decentralized social media or a developer building on the Pubky protocol.\nflowchart TD\n    Start[Want to use Pubky?] --&gt; Q1{Are you a developer?}\n    Q1 --&gt;|Yes| Dev[Install SDK]\n    Q1 --&gt;|No| User[Download Pubky Ring]\n    Dev --&gt; DevStack[Run Pubky Docker]\n    DevStack --&gt; DevBuild[Build Your App]\n    DevBuild --&gt; DevDeploy[Deploy to Production]\n    User --&gt; UserCreate[Create Identity]\n    UserCreate --&gt; UserApp[Try pubky.app]\n    UserApp --&gt; UserExplore[Explore Your Data]\n\n\nFor Users: Experience Decentralized Social Media\nStep 1: Download Pubky Ring\nPubky Ring is your key manager for the Pubky ecosystem. It securely stores your identity and authorizes apps.\n\niOS: Download from the App Store\nAndroid: Download from Google Play\n\nüîó Official Repository\nStep 2: Create Your First Pubky (Identity)\n\nOpen Pubky Ring\nFollow the onboarding flow to generate your key pair\nSave your recovery phrase securely - this is your master backup\nYour public key (pubky) is now your permanent identity!\n\nImportant: Your pubky looks like: z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty\nStep 3: Try Pubky App\nVisit pubky.app - a decentralized social media platform built on Pubky.\n\nClick ‚ÄúSign In‚Äù or ‚ÄúCreate Account‚Äù\nAuthorize Pubky App through Pubky Ring\nCreate your profile\nStart posting, following, and exploring!\n\nWhat makes it different:\n\nYou own your data (stored on homeservers)\nNo algorithm controls your feed\nYou can switch to different apps without losing your content\nTrue censorship resistance\n\nStep 4: Explore Your Data\nUse Pubky Explorer (explorer.pubky.app) to browse your data:\n\nEnter your pubky or navigate to a path\nBrowse your files and directories\nSee exactly what data you‚Äôve published\nShare direct links to your public data\n\nExample paths:\n\npubky://your-key/pub/pubky.app/profile.json - Your profile\npubky://your-key/pub/pubky.app/posts/ - Your posts directory\n\nNext Steps for Users\n\nJoin the community: Telegram\nLearn more: Read the FAQ\nUnderstand the tech: Check out ELI5: Pubky Core\nExplore concepts: Learn about Semantic Social Graph\n\n\nFor Developers: Build on Pubky\nStep 1: Install the SDK\nChoose your platform and install the Pubky SDK:\nRust:\ncargo add pubky\nJavaScript/TypeScript (Web &amp; Node.js):\nnpm install @synonymdev/pubky\n# or\nyarn add @synonymdev/pubky\nReact Native:\nnpm install @synonymdev/react-native-pubky\ncd ios &amp;&amp; pod install  # iOS only\niOS/Android Native: See SDK Documentation for UniFFI bindings via pubky-core-ffi.\nüìö Resources:\n\nRust API Docs\nNPM Package\nOfficial Docs\n\nStep 2: Run Local Development Stack\nUse Pubky Docker to run the complete Pubky ecosystem locally:\n# Clone the repository\ngit clone github.com/pubky/pubky-docker\ncd pubky-docker\n \n# Configure environment (testnet recommended for development)\ncp .env.example .env\n# Edit .env to set ENVIRONMENT=testnet\n \n# Start the stack\ndocker compose up -d\nThis gives you:\n\nPKARR relay (port 6881)\nHomeserver with PostgreSQL (port 4173)\nPubky Nexus with Neo4j &amp; Redis (port 8000)\nPubky App frontend (port 5173)\n\nAlternative: Run just a homeserver:\ngit clone github.com/pubky/pubky-core\ncd pubky-core/pubky-homeserver\ncargo run\nStep 3: Build Your First App\nQuick Example (JavaScript):\nimport { Pubky } from &#039;@synonymdev/pubky&#039;;\n \n// Create client\nconst pubky = await Pubky.create();\n \n// Generate a new identity (signup)\nconst { publicKey, secretKey } = await pubky.signUp();\nconsole.log(&#039;Your pubky:&#039;, publicKey);\n \n// Store data\nawait pubky.put(&#039;/pub/myapp/profile&#039;, JSON.stringify({\n  name: &quot;Alice&quot;,\n  bio: &quot;Building on Pubky!&quot;,\n  avatar: &quot;example.com/avatar.jpg&quot;\n}));\n \n// Retrieve data\nconst profile = await pubky.get(&#039;/pub/myapp/profile&#039;);\nconsole.log(&#039;Profile:&#039;, JSON.parse(profile));\n \n// List directory\nconst files = await pubky.list(&#039;/pub/myapp/&#039;);\nconsole.log(&#039;Files:&#039;, files);\n \n// Sign out\nawait pubky.signOut();\nKey concepts:\n\nData is stored per public key on homeservers\nPath structure: /pub/app-name/path for public data\nAll operations use standard HTTP/HTTPS\nAuthentication via cryptographic signatures\n\nüìñ Full SDK guide: SDK Documentation\nStep 4: Explore Example Apps\nLearn from working examples:\nSocial App (Pubky App Specs):\n\npubky-app-specs - Data models for social features\nnpm: pubky-app-specs - Validation schemas\n\nCLI Tool:\n\nPubky CLI - Reference implementation for user/admin operations\nSource\n\nSimple Examples:\n\npubky-core/examples - Rust examples\nAuthentication flows\nData storage patterns\n\nStep 5: Integrate Advanced Features\nUse Pubky Nexus for Social Features:\nIf building a social app, leverage Pubky Nexus for:\n\nReal-time feeds and timelines\nSearch and discovery\nUser recommendations\nNotifications\n\n// Query Nexus API\nconst response = await fetch(&#039;nexus.pubky.app/v0/feeds/global&#039;);\nconst posts = await response.json();\nüìä Nexus API Docs\nAdd Payments (WIP):\nPaykit protocol (work in progress) will enable:\n\nPayment discovery via public keys\nBitcoin/Lightning integration\nSubscriptions and monetization\n\nAdd Encryption (WIP):\nPubky Noise (work in progress) provides:\n\nEncrypted peer-to-peer channels\nPrivate messaging\nSecure data sharing\n\nStep 6: Deploy to Production\nDeploy a Homeserver:\n\nSet up a server (VPS, cloud, or self-hosted)\nConfigure HTTPS (required)\nDeploy homeserver:\ndocker build --build-arg TARGETARCH=x86_64 -t pubky:core .\ndocker run --network=host -it pubky:core\n\nPublish homeserver location to PKARR\nConfigure rate limiting and moderation\n\nüìò Guide: Homeserver Documentation\nSignup Verification:\nUse Homegate to prevent spam:\n\nSMS verification (rate-limited per phone)\nLightning payment verification\nOpen-source and self-hostable\n\nDNS Resolution:\nRun a PKDNS server for your users:\n\nResolves public key domains\nSupports traditional DNS\nDoH/DoT encryption\n\nNext Steps for Developers\n\nRead the docs: Pubky Core Overview\nStudy the architecture: Architecture Overview\nJoin the community: Telegram\nCheck the FAQ: FAQ\nReview comparisons: Comparisons with other protocols\nTroubleshooting: Troubleshooting guide\n\n\nCommon First Questions\nQ: Do users need to download Pubky Ring to use my app?\nA: Currently yes for secure key management, though apps can implement their own key storage. Pubky Ring provides the best UX for multi-app identity.\nQ: Can I use Pubky without running my own homeserver?\nA: Yes! Users can choose any public homeserver provider. You can host your own or use existing providers.\nQ: Is Pubky compatible with Nostr/Bluesky/etc?\nA: Not directly. Pubky uses a different architecture (homeservers + PKARR vs relays/PDSs). See Comparisons for details.\nQ: How do I handle user authentication?\nA: The SDK handles it automatically via signature-based auth. No passwords, OAuth, or tokens needed. See Authentication.\nQ: Can I build private apps?\nA: Currently Pubky is optimized for public data. Private/encrypted features are coming via Pubky Noise.\nQ: How do I make money?\nA: Several models work: homeserver hosting, indexing services (like Nexus), premium features, or payments via Paykit (WIP).\n\nResources\nDocumentation\n\nMain Documentation: Complete knowledge base\nGlossary: Quick term reference\nFAQ: 63+ questions answered\nTLDR: 30-second overview\n\nTechnical\n\nAPI Reference: HTTP API spec\nSDK Guide: Client library docs\nRust Docs: Rust crate documentation\nOfficial Docs: Protocol specification\n\nTools\n\nPubky Docker: Local development stack\nPubky CLI: Command-line interface\nPubky Explorer: Data browser\n\nCommunity\n\nTelegram: t.me/pubkycore\nGitHub: github.com/pubky\nLive App: pubky.app\n\n\nReady to build the decentralized web? Start with the SDK!"},"Glossary":{"title":"Glossary","links":["Explore/PubkyCore/Homeserver","Explore/PubkyApp/Backend/Aggregator","Explore/PubkyCore/Authentication","Explore/Technologies/MainlineDHT","Explore/Concepts/CredibleExit","Explore/Technologies/DHT","PKARR","Explore/Technologies/DNS","Explore/Technologies/PKDNS","Explore/Technologies/DoH","Explore/Technologies/Homegate","Explore/Technologies/JebPubkyAIBot","Explore/Technologies/KeyPair","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/PubkyNoise","Explore/Technologies/Paykit","Explore/PubkyCore/Pkarr/0.Introduction","Explore/PubkyApp/Introduction","Explore/PubkyCLI","Explore/PubkyCore/Introduction","Explore/Technologies/PubkyDocker","Explore/Technologies/PubkyExplorer","Explore/Technologies/PubkyRing","Explore/PubkyCore/SDK","Explore/Concepts/SemanticSocialGraph","/","GettingStarted","FAQ","Comparisons","TheVisionOfPubky"],"tags":[],"content":"Glossary\nQuick reference for terms used throughout the Pubky ecosystem.\n\nA\nAggregator\nA service that collects and organizes data from multiple homeservers to enable search, feeds, and discovery features. See Aggregator.\nAuthentication\nThe process of proving ownership of a public key through cryptographic signatures, enabling secure access to homeservers without passwords. See details.\nC\nCapability Token\nA cryptographically signed token that grants third-party applications limited access to a user‚Äôs data on their homeserver, similar to OAuth access tokens.\nCensorship Resistance\nThe property of being difficult or impossible to block, censor, or control by any single authority. Pubky achieves this through decentralized Mainline DHT and distributed homeservers.\nCredible Exit\nThe ability to leave a service provider (homeserver, app, etc.) without losing your data, identity, or social connections. A core principle of Pubky‚Äôs architecture.\nD\nDistributed Hash Table (DHT)\nA decentralized key-value storage system distributed across many nodes. Pubky uses Mainline DHT for storing PKARR records.\nDomain Name System (DNS)\nTraditional system for translating domain names to IP addresses. PKDNS extends this to support public key domains.\nDNS over HTTPS (DoH)\nProtocol for encrypting DNS queries using HTTPS, preventing surveillance and tampering.\nH\nHomeserver\nA web server that stores user data in a key-value format. Users can run their own or choose any provider. Data is stored per public key and accessed via HTTP/HTTPS.\nHomegate\nA signup verification service for homeservers, providing SMS and Lightning Network payment verification to prevent spam while preserving privacy.\nI\nIndexer\nSee Aggregator. A service that crawls and indexes data from homeservers to provide search and discovery features.\nJ\nJeb\nAI-powered bot for the Pubky social network, providing post summaries and fact-checking capabilities using LLMs and web search.\nK\nKey Pair\nA pair of cryptographic keys (public and private) used for identity, authentication, and encryption. In Pubky, your public key IS your identity.\nM\nMainline DHT\nThe Distributed Hash Table used by BitTorrent, with 10+ million nodes globally. Pubky uses it to store PKARR records, providing censorship-resistant discovery.\nN\nNexus (Pubky Nexus)\nProduction-grade indexing and aggregation service for Pubky App. Provides high-performance social graph API, search, and real-time notifications.\nNoise (Pubky Noise)\nNoise Protocol implementation for encrypted peer-to-peer communication in the Pubky ecosystem (work in progress).\nP\nPaykit\nPayment protocol built on Pubky for payment discovery and coordination across Bitcoin, Lightning, and other methods (work in progress).\nPKARR (Public Key Addressable Resource Records)\nSelf-issued, signed DNS-like records published to the Mainline DHT. Each record is tied to a public key and contains information like homeserver locations.\nPKDNS\nDNS server that resolves public key domains by fetching PKARR records from the Mainline DHT, bridging traditional DNS with decentralized identity.\nPublic Key\nThe public half of a cryptographic key pair. In Pubky, this serves as your permanent, self-sovereign identity (often called a ‚Äúpubky‚Äù).\nPubky\n\nThe decentralized web protocol and ecosystem\nA user‚Äôs public key identity (e.g., ‚Äúmy pubky is z4e8s‚Ä¶‚Äú)\n\nPubky App\nSocial media application demonstrating Pubky Core capabilities. Currently live at pubky.app as MVP, with next-gen ‚ÄúFranky‚Äù client in development.\nPubky CLI\nCommand-line tool for interacting with Pubky homeservers, providing user operations, admin functions, and testing utilities.\nPubky Core\nThe foundational protocol, homeserver implementation, and SDK for building decentralized applications on Pubky.\nPubky Docker\nDocker Compose orchestration for running the complete Pubky Social stack locally with one command.\nPubky Explorer\nWeb-based file browser for exploring public data on Pubky homeservers. Available at explorer.pubky.app.\nPubky Ring\nMobile key manager app (iOS/Android) for securely managing pubkys, authorizing applications, and handling sessions.\npubky-app-specs\nFormal data model specifications for Pubky App, defining structures for users, posts, tags, and other social features. Ensures interoperability between different client implementations.\nR\nRecovery File\nEncrypted backup of a user‚Äôs private key and identity information, protected by a passphrase. Used for key recovery and migration between devices.\nS\nSDK (Software Development Kit)\nClient libraries for building Pubky applications, available in Rust, JavaScript/WASM, and native mobile (iOS/Android).\nSelf-Sovereign Identity\nIdentity that is fully controlled by the individual, not dependent on any centralized authority or service provider. Pubky implements this via cryptographic key pairs.\nSemantic Social Graph\nA social network where relationships are tagged with meaningful metadata, enabling personalized content filtering, trust-based discovery, and user-controlled feeds.\nSession\nA time-limited authentication state that allows a client to access a homeserver without repeatedly signing requests with the private key.\nT\nTag\nUser-defined label attached to posts, files, or other users to add semantic meaning and enable filtering/discovery in the Semantic Social Graph.\nW\nWeb of Trust\nTraditional model where trust propagates through social connections. Pubky extends this with the Semantic Social Graph, adding semantic context to trust relationships.\n\nQuick Links\n\nMain Documentation: Full knowledge base\nGetting Started: Get started with Pubky\nFAQ: Frequently asked questions\nComparisons: How Pubky compares to alternatives\nVision: Why we‚Äôre building Pubky\n"},"Readme":{"title":"Readme","links":["LICENSE","Contributing"],"tags":[],"content":"Pubky Knowledge Base\n\n\nWelcome to the Pubky Knowledge base - we are excited to have you here!\nüîó Access the Pubky Knowledge Base\n\nThe current Knowledge base is a mix of reality, dreams, visions, actuality and plans.\n\nThe Knowledge Base is a comprehensive resource that encompasses our vision for Pubky, along with detailed explanations of the architecture for both Pubky Core and Pubky App, as well as key concepts and practical guides.\nüìù Contributing to Documentation\nWe kindly ask you to help us improve this documentation for a clearer, more accurate, and concise knowledge base.\nQuick Fixes\nFor typos, broken links, or small improvements:\n\nFork this repository\nMake your changes\nSubmit a pull request\n\nLarger Contributions\nFor new pages or significant changes:\n\nOpen an issue to discuss your plans first\nFollow the Contributing guide\nTest locally before submitting\n\nSee our full Contributing Guide for detailed instructions.\nüèóÔ∏è Build Static Site Locally\nThe knowledge base is built using Quartz, a static site generator optimized for knowledge bases.\nPrerequisites\n\nNode.js 18+ installed\n\nBuild Steps\n# 1. Navigate to quartz directory\ncd quartz\n \n# 2. Install dependencies\nnpm install\n \n# 3. Build and serve locally\nnpm run docs\n \n# 4. Open browser\n# Visit http://localhost:8080\nProduction Build\ncd quartz\nnpm run build\nOutput will be in quartz/public/ directory.\nüîó Related Resources\n\nOfficial Website: pubky.org\nMain Repository: github.com/pubky/pubky-core\nTelegram: t.me/pubkycore\nLive App: pubky.app\n\nüìú License\nThis documentation is licensed under the MIT License. See LICENSE for details.\n\nFor GitHub Contributors: This README is specifically for the documentation repository. The actual knowledge base lives at pubky.org."},"TLDR":{"title":"TLDR","links":["Explore/PubkyCore/Introduction","Explore/Technologies/PubkyRing","Explore/PubkyApp/Introduction","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/Paykit","Explore/Technologies/PubkyNoise","GettingStarted","Explore/PubkyCore/SDK","/","FAQ","Glossary","TheVisionOfPubky"],"tags":[],"content":"Pubky: 30-Second Overview\nPubky is a decentralized web protocol that puts you in control of your identity and data.\nWhat It Is\n\nYour Identity = Your Key: No usernames, no accounts. Your public key is your permanent identity.\nYour Data, Your Choice: Store data on any homeserver you choose. Switch anytime without losing anything.\nCensorship Resistant: Built on the Mainline DHT (15+ years proven, 10M+ nodes). No single authority can block you.\nNo Blockchain: Fast, free operations using standard web technologies (HTTP/HTTPS).\n\nHow It Works\nflowchart LR\n    You[Your Key] --&gt; PKARR[PKARR Record]\n    PKARR --&gt; DHT[Mainline DHT]\n    PKARR --&gt; HS[Your Homeserver]\n    Apps[Apps] --&gt; HS\n    Apps --&gt; DHT\n\n\nGenerate a cryptographic key pair (your identity)\nPublish a PKARR record to the DHT (points to your homeserver)\nStore your data on any homeserver\nApps discover and access your data via your public key\n\nKey Components\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponentPurposeStatusPubky CoreProtocol, homeserver, SDK‚úÖ ProductionPubky RingMobile key manager (iOS/Android)‚úÖ ProductionPubky AppSocial media demo (pubky.app)‚úÖ Live (MVP)Pubky NexusSocial indexing service‚úÖ ProductionPaykitPayment protocol‚ö†Ô∏è WIPPubky NoiseEncrypted communication‚ö†Ô∏è WIP\nWhy It Matters\nReplace Big Tech: No algorithm controls your feed. No company owns your data.\nReplace Big State: Censorship becomes impractical when data lives on millions of distributed nodes.\nReplace Big Banks: Native integration with Bitcoin/Lightning for true financial freedom (coming soon).\nGet Started\n\nUsers: Download Pubky Ring ‚Üí Try pubky.app\nDevelopers: Check Getting Started Guide ‚Üí Install SDK\n\nLearn More\n\nFull Documentation: Complete knowledge base\nFAQ: 63 questions answered\nGlossary: Quick term definitions\nVision: Why we‚Äôre building this\n\n\nBottom Line: Pubky gives you a self-sovereign identity, censorship-resistant data storage, and the freedom to choose your own infrastructure‚Äîall using proven, scalable technology."},"TheVisionOfPubky":{"title":"The Vision of Pubky","links":[],"tags":[],"content":"Decentralizing Our Future\nImagine a future where our online relationships are no longer dictated by corporate giants or state-controlled systems, where you decide how to connect, who to trust, and where to store your data. This is the vision of Pubky: a decentralized, user-first web that breaks the toxic cycle of dependency on Big Tech, Big State, and Big Banks.\nPubky is not just a platform‚Äîit is an ecosystem designed to provide tools for communication, social coordination, identity management, and, eventually, financial freedom, all in one interconnected framework. Pubky will harness the power of decentralized identity, censorship resistance, semantic social graphs, and Bitcoin and Lightning Network technology to create an open web that prioritizes user autonomy.\nReplacing Big Tech: Credible Exit, Censorship Resistance, and User-Controlled Experience\nBig Tech platforms like social media giants use algorithms that limit freedom, exploit engagement, and control the flow of information. Pubky proposes a different kind of web‚Äîone built on Semantic Social Graphs and self-sovereign identities. Instead of opaque algorithms deciding what is relevant to you, Semantic Social Graphs and PKARR give users full control over their digital interactions. This system gives control back to individuals, helping replace our toxic relationship with Big Tech.\n\n\nPKARR for Credible Exit and Censorship Resistance: With PKARR, users can create decentralized identities that allow them to leave any service without losing their content, identity, or relationships. PKARR also makes censorship resistance possible by ensuring that users‚Äô identities are independent of any specific server. This means users can migrate to other services when needed, maintaining their control and avoiding censorship.\n\n\nSemantic Social Graphs for Personalized Control: Semantic Social Graphs empower users by allowing them to enrich their relationships, determine trustworthiness, and organize content in a meaningful way. Users choose what they see, whom they trust, and how information flows within their network.\n\n\nPubky App for User-Controlled Feeds: The Pubky App allows users to decide which data appears in their feeds. Unlike traditional platforms where algorithms push content for maximum engagement, Pubky gives users the power to tag, filter, and prioritize the content that matters most to them. This approach replaces toxic algorithms with user-defined preferences, ensuring a healthier online experience.\n\n\nHomeservers for Decentralized Hosting: Homeservers allow for decentralized data hosting and competitive hosting services by enabling users to migrate away from any server that changes its policies or restricts their content. This means that censorship is anticipated and dealt with, allowing users to keep control over their digital presence.\n\n\nReplacing Big State: Self-Sovereign Identity and Peer Regulation\nGovernments often use centralized systems to control speech, monitor user activity, and dictate identity management. Pubky provides an alternative‚Äîa decentralized network that makes censorship impractical and gives users self-sovereign identity. With Pubky, PKARR (Public Key Addressable Roles and Resources), Mainline DHT, and Semantic Social Graphs ensure that users are empowered to self-regulate, verify authenticity, and maintain control of their identities without relying on centralized authorities. This means:\n\n\nSelf-Sovereign Identity with PKARR: Pubky allows users to create key-based identities using PKARR, giving them the freedom to establish and manage their identities without permission from any central entity. Users can choose whether to remain anonymous or become publicly identifiable, and no central authority can revoke or control their identity.\n\n\nDecentralized Directory with Mainline DHT: Mainline DHT acts as a distributed directory, helping users locate and connect with each other without relying on a centralized server. This peer-to-peer system ensures that users are always discoverable by those they trust, even in the face of censorship attempts.\n\n\nSemantic Social Graphs for Peer Regulation: Pubky‚Äôs Semantic Social Graphs are key to creating an environment of self-regulation among users. By allowing users to add context, trust levels, and tags to their connections, Pubky provides the foundation for automating business logic on top of graph metadata and relationships. This means that users can set the rules for how they interact with others, creating systems of accountability and shared trust that do not depend on external regulation.\n\n\nIn this way, Pubky replaces the need for a centralized authority (the ‚ÄúBig State‚Äù) by empowering users to be self-sovereign and enabling communities to regulate themselves. Pubky provides the tools to make censorship difficult and autonomy possible‚Äîgiving users the power to govern their online interactions and identities independently.\nReplacing Big Banks: Competing with Fiat and Enabling Financial Freedom\nBeyond communication and social interaction, Synonym also seeks to empower individuals financially. Our reliance on Big Banks and centralized financial systems means losing autonomy over our own wealth. Pubky envisions a future where financial freedom is possible through the use of  Bitcoin and the Lightning Network to decouple payments from hosted platforms and middlemen.\n\n\nBitcoin creates competition for fiat currencies and traditional speculative investments by offering a decentralized, permissionless currency. Users are in full control of their funds, able to send or receive value directly from their own wallets, free from the constraints of centralized banking institutions.\n\n\nBitkit Mobile Wallet: Synonym, creators of Pubky, also offers the Bitkit mobile wallet, which supports Bitcoin, Lightning, and soon Pubky features, providing a unified solution for users to manage their identities, financial transactions, and online presence‚Äîall in a decentralized manner.\n\n\nCommerce features and tools are planned for future versions of Pubky, with a long term goal of a totally dynamic digital social economy!\n\n\nA Future of Freedom and Autonomy\nOur vision is simple: to build a digital world where individuals are in charge, rather than corporations or governments. By integrating decentralized identities, censorship-resistant technologies, and financial independence, we can replace our toxic dependency on centralized powers with an open, user-controlled web.\nImagine a future where your data, your identity, and your financial assets are truly yours. Where you decide what to share, whom to trust, and how to connect‚Äîwithout any company or government watching over your shoulder. Synonym is building this future, creating an internet that works for people, not against them.\nJoin us in this movement toward decentralization, censorship resistance, and true digital autonomy."},"Troubleshooting":{"title":"Troubleshooting","links":["Explore/PubkyCore/Authentication","/","GettingStarted","FAQ","Explore/PubkyCore/SDK","Explore/Technologies/PKDNS","Explore/PubkyCore/Homeserver"],"tags":[],"content":"Troubleshooting Guide\nCommon issues and solutions when working with Pubky.\n\nPKARR &amp; Discovery Issues\nPKARR Record Not Resolving\nSymptom: Public key domain doesn‚Äôt resolve, apps can‚Äôt find homeserver\nCommon Causes:\n\n\nRecord Not Published\n# Verify record exists on DHT\ncurl &quot;pkarr.pubky.org/&lt;your-public-key&gt;&quot;\nSolution: Ensure you‚Äôve published your PKARR record:\nawait pubky.publishPkarrRecord();\n\n\nRecord Expired (TTL)\n\nPKARR records on DHT expire after several hours\nSolution: Republish regularly (recommended: every 2 hours)\n\n// Automatic republishing\nsetInterval(async () =&gt; {\n  await pubky.publishPkarrRecord();\n}, 2 * 60 * 60 * 1000); // Every 2 hours\n\n\nDHT Propagation Delay\n\nRecords take time to propagate (usually &lt; 5 minutes)\nSolution: Wait a few minutes after publishing, then retry\n\n\n\nIncorrect Public Key Format\n\nPublic keys must be z-base-32 encoded\nSolution: Verify key format matches: z4e8s17cou9qmuwen8p1556jzhf1wktmzo6ijsfnri9c4hnrdfty\n\n\n\nDebugging Commands:\n# Check if PKARR relay has your record\ncurl &quot;pkarr.pubky.org/&lt;public-key&gt;&quot;\n \n# Check DNS resolution via PKDNS\ndig @pkdns.pkarr.org &lt;public-key&gt;\n \n# Test with Pubky CLI\npubky-cli tools verify-pkarr &lt;public-key&gt;\n\nHomeserver Connection Issues\nCan‚Äôt Connect to Homeserver\nSymptom: SDK operations fail, timeout, or refuse connection\nCommon Causes:\n\n\nHTTPS Not Configured\n\nHomeservers REQUIRE HTTPS (not HTTP)\nSolution: Configure TLS certificate:\n\n# Using Let&#039;s Encrypt\ncertbot --nginx -d yourdomain.com\n\n\nFirewall Blocking Ports\n\nDefault ports: 6287 (user API), 6288 (admin API)\nSolution: Open firewall ports:\n\n# UFW example\nsudo ufw allow 6287/tcp\nsudo ufw allow 6288/tcp\n\n\nHomeserver Not Running\n\nSolution: Verify homeserver is running:\n\n# Check process\nps aux | grep pubky-homeserver\n \n# Check logs\njournalctl -u pubky-homeserver -f\n\n\nPKDNS Resolution Failure\n\nBrowser can‚Äôt resolve public key domain\nSolution: Use PKDNS-enabled resolver or DoH:\n\n// In browser, use full HTTPS URL\nconst url = `your-homeserver.com/pub/...`;\n\n\nTest Connection:\n# Direct test\ncurl your-homeserver.com/\n \n# Via public key (requires PKDNS)\ncurl $(pkdns resolve &lt;public-key&gt;)/\n\nSDK Authentication Problems\nSee Authentication for how Pubky authentication works.\n‚ÄùInvalid Signature‚Äù or ‚ÄúAuthentication Failed‚Äù\nSymptom: SDK operations rejected with authentication errors\nCommon Causes:\n\n\nRecovery File Corrupted\n\nFile is damaged or incorrectly decrypted\nSolution: Restore from backup or regenerate keys\n\n\n\nWrong Passphrase\n\nRecovery file passphrase is incorrect\nSolution: Verify passphrase, use correct one:\n\nconst pubky = await Pubky.fromRecoveryFile(\n  &#039;./recovery.file&#039;,\n  &#039;correct-passphrase&#039;\n);\n\n\nSession Expired\n\nSessions have TTL (typically 24 hours)\nSolution: Sign in again:\n\nawait pubky.signIn();\n\n\nClock Skew\n\nSystem time is significantly wrong\nSolution: Sync system clock:\n\n# Linux/macOS\nsudo ntpdate -s time.nist.gov\n \n# Or use NTP service\nsudo systemctl restart systemd-timesyncd\n\n\nDebug Authentication:\n// Check current session\nconst session = await pubky.session();\nconsole.log(&#039;Session valid:&#039;, session.valid);\nconsole.log(&#039;Expires:&#039;, new Date(session.expiresAt));\n \n// Force re-authentication\nawait pubky.signOut();\nawait pubky.signIn();\n\nPubky Docker Setup Issues\nContainers Won‚Äôt Start\nSymptom: docker compose up fails or containers crash\nCommon Causes:\n\n\nPort Conflicts\n\nAnother service using required ports\nSolution: Check and free ports:\n\n# Find what&#039;s using ports\nsudo lsof -i :4173  # Homeserver\nsudo lsof -i :6881  # PKARR relay\nsudo lsof -i :8000  # Nexus\n \n# Kill conflicting process or change ports in .env\n\n\nInsufficient Resources\n\nDocker doesn‚Äôt have enough memory/CPU\nSolution: Increase Docker resources:\nDocker Desktop ‚Üí Settings ‚Üí Resources ‚Üí Memory: 8GB+\n\n\n\nEnvironment Variables Missing\n\n.env file not configured\nSolution: Copy and configure:\n\ncp .env.example .env\n# Edit .env with your settings\n\n\nVolume Permission Issues\n\nDocker can‚Äôt write to volumes\nSolution: Fix permissions:\n\nsudo chown -R $USER:$USER ./data\n\n\nDebug Docker:\n# View logs\ndocker compose logs -f\n \n# Check container status\ndocker compose ps\n \n# Restart services\ndocker compose restart\n \n# Full reset\ndocker compose down -v\ndocker compose up -d\nDatabase Connection Errors\nSymptom: Nexus or Homeserver can‚Äôt connect to Postgres/Neo4j\nSolution:\n# Check database containers are running\ndocker compose ps postgres neo4j redis\n \n# Restart database services\ndocker compose restart postgres neo4j redis\n \n# Check database logs\ndocker compose logs postgres\ndocker compose logs neo4j\n\nData Operations Issues\nPUT/DELETE Operations Fail\nSymptom: Can‚Äôt store or delete data on homeserver\nCommon Causes:\n\n\nInvalid Path\n\nPath must start with /pub/ for public data\nSolution: Use correct path format:\n\n// ‚úÖ Correct\nawait pubky.put(&#039;/pub/myapp/data.json&#039;, data);\n \n// ‚ùå Wrong\nawait pubky.put(&#039;data.json&#039;, data);\nawait pubky.put(&#039;/myapp/data.json&#039;, data);\n\n\nData Too Large\n\nHomeserver has size limits (default: ~10MB per file)\nSolution: Split large data or increase homeserver limit\n\n\n\nRate Limiting\n\nToo many requests in short time\nSolution: Implement backoff:\n\nasync function putWithRetry(path, data, retries = 3) {\n  for (let i = 0; i &lt; retries; i++) {\n    try {\n      return await pubky.put(path, data);\n    } catch (e) {\n      if (e.status === 429) {\n        await new Promise(r =&gt; setTimeout(r, 1000 * (i + 1)));\n      } else throw e;\n    }\n  }\n}\n\n\nInsufficient Permissions\n\nTrying to write to another user‚Äôs space\nSolution: Verify you‚Äôre writing to your own pubky\n\n\n\n\nPubky Ring Issues\nCan‚Äôt Create Identity\nSymptom: Key generation fails in Pubky Ring app\nSolutions:\n\nUpdate the app: Check for latest version\nClear app cache: Settings ‚Üí Storage ‚Üí Clear Cache\nReinstall: Uninstall and reinstall (backup recovery phrase first!)\n\nApp Authorization Fails\nSymptom: Pubky Ring doesn‚Äôt authorize app requests\nSolutions:\n\nCheck app URL: Ensure correct app origin\nRe-scan QR code: Try authorization flow again\nCheck Ring permissions: Ensure app has necessary permissions\n\n\nNetwork &amp; Performance Issues\nSlow PKARR Lookups\nSymptom: Discovery takes a long time\nSolutions:\n\n\nUse PKARR relay: Faster than direct DHT:\nconst config = {\n  pkarrRelay: &#039;pkarr.pubky.org&#039;\n};\n\n\nCache aggressively: Store resolved homeserver URLs:\nconst cache = new Map();\nif (cache.has(publicKey)) {\n  return cache.get(publicKey);\n}\n\n\nUse local PKDNS: Run your own PKDNS server for faster resolution\n\n\nHigh Latency Requests\nSymptom: Homeserver operations are slow\nSolutions:\n\nChoose geographically close homeserver\nCheck homeserver load: May be overloaded\nUse CDN: Cache static data\nOptimize request batching: Group operations\n\n\nCommon Error Messages\n‚ÄùFailed to fetch PKARR record‚Äù\nCauses: DHT unreachable, record doesn‚Äôt exist, network issues\nSolutions:\n\nCheck internet connection\nVerify record was published\nTry different PKARR relay\nWait for DHT propagation\n\n‚ÄùHomeserver not found‚Äù\nCauses: PKARR record has no homeserver entries, DNS resolution failed\nSolutions:\n\nVerify PKARR record contains homeserver URL\nCheck PKDNS is working\nTest direct homeserver URL access\n\n‚ÄùSession expired‚Äù\nCauses: Auth session TTL passed\nSolutions:\n\nSign in again\nImplement automatic re-authentication\n\n‚ÄùPermission denied‚Äù\nCauses: Trying to access/modify unauthorized data\nSolutions:\n\nCheck capability tokens\nVerify you own the data\nRequest proper permissions\n\n\nGetting Help\nCommunity Support\n\nTelegram: t.me/pubkycore\nGitHub Issues: github.com/pubky/pubky-core/issues\nDocumentation: Knowledge Base\n\nReporting Bugs\nWhen reporting bugs, include:\n\nEnvironment: OS, browser/platform version, SDK version\nSteps to reproduce: Exact sequence that causes the issue\nError messages: Full error text and stack traces\nExpected vs actual: What should happen vs what happens\nLogs: Relevant logs from homeserver/client\n\nExample:\n## Environment\n- OS: macOS 14.2\n- SDK: @synonymdev/pubky@0.6.0\n- Browser: Chrome 120\n \n## Steps to Reproduce\n1. Call `await pubky.put(&#039;/pub/test/file.json&#039;, data)`\n2. Observe error\n \n## Error Message\nError: Failed to PUT /pub/test/file.json: 500 Internal Server Error\n\n## Expected\nData should be stored successfully\n\n## Actual\n500 error returned\n\nUseful Debugging Tools\nBrowser DevTools:\n// Enable verbose logging\nlocalStorage.setItem(&#039;pubky:debug&#039;, &#039;true&#039;);\n \n// Check network requests\n// Open DevTools ‚Üí Network tab ‚Üí Filter: pubky\nCommand Line:\n# Test PKARR\ncurl &quot;pkarr.pubky.org/&lt;public-key&gt;&quot;\n \n# Test homeserver\ncurl -v &quot;homeserver.com/pub/...&quot;\n \n# Check DNS\ndig @8.8.8.8 &lt;public-key&gt;\n \n# Test PKDNS\ndig @pkdns.pkarr.org &lt;public-key&gt;\nPubky CLI:\n# Check user info\npubky-cli user session ./recovery.file\n \n# Test data operations\npubky-cli user get /pub/test ./recovery.file\n \n# Admin diagnostics\nPUBKY_ADMIN_PASSWORD=admin pubky-cli admin info\n\nSee Also\n\nGetting Started: Setup guides\nFAQ: Frequently asked questions\nSDK Documentation: Detailed API docs\nPKDNS: DNS resolution details\nHomeserver: Homeserver administration\n"},"index":{"title":"Pubky Knowledge Base","links":["Explore/PubkyCore/Introduction","Explore/PubkyCore/Pkarr/0.Introduction","Explore/PubkyApp/Introduction","Explore/PubkyCore/Homeserver","Explore/Concepts/Censorship","Explore/Concepts/CredibleExit","Explore/Concepts/SemanticSocialGraph","TheVisionOfPubky","TLDR","GettingStarted","Glossary","Comparisons","FAQ","Explore/Technologies/PubkyRing","Explore/Technologies/PubkyExplorer","Explore/PubkyCore/SDK","Explore/PubkyCore/API","Architecture","Explore/Technologies/Homegate","Explore/Technologies/PKDNS","Explore/PubkyApp/Backend/PubkyNexus","Explore/Technologies/PubkyDocker","Explore/Technologies/PubkyCLI","Explore/Technologies/JebPubkyAIBot","Explore/Technologies/MainlineDHT","Explore/Technologies/Paykit","Explore/Technologies/PubkyNoise","Troubleshooting","Contributing"],"tags":[],"content":"Welcome to the Pubky Knowledge Base\nThis is a knowledge base for the Pubky platform, which includes Pubky Core, PKARR and Pubky App. These documents are a work in progress, much like Pubky‚Äôs protocols and applications!\nWhat is Pubky?\nPubky attempts to unlock the web by realizing our vision for a key-based, self-regulating web that puts users in control.\nSo far, Pubky does this by combining practical decentralized routing &amp; identity (PKARR), with simple interoperable hosting (Homeservers) that allow for censorship resistance and a credible exit, as well as a publishing application, Pubky App, that facilitates the creation of a Semantic Social Graph, which can be used for filtering, discovery, matching and coordination.\nLearn more about the overall vision here: The Vision of Pubky\nQuick Start\n\nTLDR: 30-second overview of the entire ecosystem\nGetting Started: Complete guide for users and developers\nGlossary: Quick reference for key terms\nComparisons: How Pubky compares to other protocols\nFrequently Asked Questions (FAQ): 63+ questions answered\n\nFor Users\nTry Pubky\n\nPubky Ring - Download the mobile key manager app (iOS/Android)\nPubky.app - Try the social media application\nPubky Explorer - Browse your data at explorer.pubky.app\n\nIdentity Management\nüîê Pubky Ring is the key manager app for the Pubky ecosystem. Native mobile app (iOS/Android) for managing your pubkys, authorizing apps, and controlling sessions.\n\nPubky Ring Overview - Your keychain for decentralized identity\nOfficial Repository - React Native mobile app\n\nFor Developers: Pubky Core\nüèóÔ∏è Pubky Core is the open protocol and infrastructure for building censorship-resistant web applications.\nCore Documentation\n\nPubky Core Overview - Protocol, homeserver, and SDK\nSDK Documentation - Client libraries (Rust, JavaScript, iOS, Android)\nAPI Reference - RESTful HTTP API specification\nArchitecture Overview - System design and data flow\nHomeserver Documentation - Deploy and configure homeservers\n\nInfrastructure\n\nHomegate - Signup verification service for homeservers (SMS + Lightning)\nPKDNS - DNS server for resolving public key domains\nPubky Nexus - Production indexing service\n\nResources\n\nOfficial Repository - MIT licensed\nOfficial Docs - Complete documentation\nRust API Docs - Rust crate documentation\nNPM Package - JavaScript/TypeScript bindings\n\nDeveloper Tools\nüõ†Ô∏è Pubky Ecosystem Tools - Utilities for development, debugging, and exploration:\n\nPubky Docker - One-click Docker stack for running the complete Pubky Social environment locally\nPubky Explorer - Web-based file browser for homeserver data (explorer.pubky.app)\nPubky CLI - Command-line tool for homeserver management and testing\nPKDNS Digger - Web-based DNS record lookup tool for PKARR domains (github.com/pubky/pkdns-digger)\nJeb AI Bot - AI-powered bot for summaries and fact-checking on Pubky social network\n\nPubky App: Social Application\nPubky App is a decentralized social media application built on Pubky Core.\nCurrent Status\n\nLive Application: pubky.app - Production PWA currently operational\nCurrent Repository: github.com/pubky/pubky-app - ‚ö†Ô∏è Deprecated (MVP codebase)\nNew Development: github.com/pubky/franky - Work in Progress (next-gen client, expected summer 2025)\nData Model Specification: pubky-app-specs - Formal schema definitions for interoperability\n\nBackend Infrastructure\nüöÄ Pubky Nexus is the production indexing and aggregation service that powers Pubky App‚Äôs social features.\n\nPubky Nexus Overview - Real-time social graph aggregation and high-performance API\nOfficial Repository - Open source Rust implementation\nLive API - Production REST API with Swagger UI\nStaging API - Latest development version\n\nKey Concepts\nUnderstand the fundamental ideas behind Pubky:\n\nSemantic Social Graph - Tagged relationships and user-controlled filtering\nCensorship Resistance - Why centralized platforms fail\nCredible Exit - Freedom to switch providers without losing data\nPKARR - Public key addressable resource records\nMainline DHT - Distributed hash table for discovery\n\nWork in Progress: Payment Protocol\n‚ö†Ô∏è Paykit is a payment protocol (work in progress) built on Pubky for payment discovery and coordination. Not production-ready.\n\nPaykit Overview - Current state and architecture (WIP)\nFork Repository (WIP) - BitcoinErrorLog fork\nComplete Documentation - Repository docs (work in progress)\n\nWork in Progress: Encrypted Communication\n‚ö†Ô∏è Pubky Noise is a Noise Protocol implementation (work in progress) for encrypted peer-to-peer communication in the Pubky ecosystem. Not production-ready.\n\nPubky Noise Overview - Encrypted channels for private communication (WIP)\nRepository (WIP) - BitcoinErrorLog fork\n\nCommunity &amp; Support\n\nGetting Started - Complete onboarding guide\nFAQ - Frequently asked questions\nTroubleshooting - Common issues and solutions\nContributing - How to contribute to Pubky\nTelegram: t.me/pubkycore\nGitHub: github.com/pubky\n\n\nReady to get started? Check out the Getting Started guide or dive into Pubky Core!"}}